#include "rk_common.h"
#include "rk_usb.h"
#include "./libusb/libusb.h"


#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))

static chip_t chips[] =
{
    { 0x0000, "UNKNOWN"},
    { 0x110c, "RK1106" },
    { 0x180a, "RK1808" },
    { 0x281a, "RK2818" },
    { 0x290a, "RK2918" },
    { 0x292a, "RK2928" },
    { 0x292c, "RK3026" },
    { 0x300a, "RK3066" },
    { 0x300b, "RK3168" },
    { 0x301a, "RK3036" },
    { 0x310a, "RK3066" },
    { 0x310b, "RK3188" },
    { 0x310c, "RK3128" },
    { 0x320a, "RK3288" },
    { 0x320b, "RK3228" },
    { 0x320c, "RK3328" },
    { 0x330a, "RK3368" },
    { 0x330c, "RK3399" },
    { 0x330d, "PX30" },
    { 0x330e, "RK3308" },
    { 0x350a, "RK3568" },
    { 0x350b, "RK3588" },
    { 0x350d, "RK3562" },
    { 0x350e, "RK3576" },
    { 0x350f, "RK3506" },
};


static inline void __put_unaligned_le16(uint8_t* p, uint16_t val) { *p++ = uint8_t(val); *p++ = uint8_t(val >> 8); }
static inline void __put_unaligned_be16(uint8_t* p, uint16_t val) { *p++ = uint8_t(val >> 8); *p++ = uint8_t(val); }
static inline void __put_unaligned_le32(uint8_t* p, uint32_t val) { __put_unaligned_le16(p + 2, val >> 16); __put_unaligned_le16(p, val); }
static inline void __put_unaligned_be32(uint8_t* p, uint32_t val) { __put_unaligned_be16(p, val >> 16); __put_unaligned_be16(p + 2, val); }

static inline uint32_t __get_unaligned_be32(const uint8_t* p) { return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | (p[3] << 0); }
static inline uint32_t __get_unaligned_le32(const uint8_t* p) {  return (p[0] << 0) | (p[1] << 8) | (p[2] << 16) | (p[3] << 24); }

static inline void put_unaligned_be16(void* p, uint16_t val) { __put_unaligned_be16((uint8_t*)p, val); }
static inline void put_unaligned_le32(void* p, uint32_t val) { __put_unaligned_le32((uint8_t*)p, val); }
static inline void put_unaligned_be32(void* p, uint32_t val) { __put_unaligned_be32((uint8_t*)p, val); }

static inline uint32_t get_unaligned_be32(const void* p) { return __get_unaligned_be32((const uint8_t*)p); }
static inline uint32_t get_unaligned_le32(const void* p) { return __get_unaligned_le32((const uint8_t*)p); }


RK_usb::RK_usb()
{
    libusb_init(&m_context);
    m_handle  = NULL;
    m_chip = &chips[0];

    m_epout = 0;
    m_epin  = 0;
}


RK_usb::~RK_usb()
{
    if(m_handle)
        libusb_close(m_handle);
    libusb_exit(m_context);
}


bool RK_usb::init()
{
    libusb_device** list = NULL;
    bool found = false;
    if(m_handle)
        return true;
    m_maskrom = false;
    bool error_open_libusb = false;
    for(int32_t count = 0; (count < libusb_get_device_list(m_context, &list)) && !found; count++)
    {
        libusb_device_descriptor desc;
        libusb_device* device = list[count];
        libusb_device_handle* hdl;
        if(libusb_get_device_descriptor(device, &desc) == 0)
        {
            if(desc.idVendor == 0x2207)
            {
                for(size_t i = 0; i < ARRAY_SIZE(chips); i++)
                {
                    if(desc.idProduct == chips[i].pid)
                    {
                        if(libusb_open(device, &hdl) == 0)
                        {
                            m_handle = hdl;
                            m_chip = &chips[i];
                            found = true;
                            break;
                        }
                        error_open_libusb = false;
                    }
                }
                if(!found)
                {
                    if(libusb_open(device, &hdl) == 0)
                    {
                        m_handle  = hdl;
                        m_chip = &chips[0];
                        found  = true;
                        break;
                    }
                    error_open_libusb = false;
                }
            }
        }
    }

    if(m_handle && m_chip && found)
    {
        if(libusb_kernel_driver_active(m_handle, 0))
            libusb_detach_kernel_driver(m_handle, 0);

        if(libusb_claim_interface(m_handle, 0) == 0)
        {
            libusb_device_descriptor desc;
            if(libusb_get_device_descriptor(libusb_get_device(m_handle), &desc) == 0)
            {
                m_maskrom = ((desc.bcdUSB & 0x0001) == 0x0000);
                libusb_config_descriptor* config;
                if(libusb_get_active_config_descriptor(libusb_get_device(m_handle), &config) == 0)
                {
                    for(size_t if_idx = 0; if_idx < config->bNumInterfaces; if_idx++)
                    {
                        const libusb_interface* iface = config->interface + if_idx;
                        for(size_t set_idx = 0; set_idx < (size_t)iface->num_altsetting; set_idx++)
                        {
                            const libusb_interface_descriptor* setting = iface->altsetting + set_idx;
                            for(size_t ep_idx = 0; ep_idx < setting->bNumEndpoints; ep_idx++)
                            {
                                const libusb_endpoint_descriptor* ep = setting->endpoint + ep_idx;
                                if((ep->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) != LIBUSB_TRANSFER_TYPE_BULK)
                                    continue;
                                if((ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK) == LIBUSB_ENDPOINT_IN)
                                    m_epin = ep->bEndpointAddress;
                                else
                                    m_epout = ep->bEndpointAddress;
                            }
                        }
                    }
                    libusb_free_config_descriptor(config);
                    return true;
                }
            }
        }
    }
    if(error_open_libusb)
        printf("Driver device not use libusb\r\n");
    return false;
}


const char* RK_usb::chip_name()
{
    return m_chip->name;
}


bool RK_usb::maskrom_upload_memory(uint32_t code, void* buf, uint64_t len)
{
    uint64_t total = 0;
    uint16_t crc16 = 0xffff;
    bool pend = false;
    uint8_t* buffer = (uint8_t*)malloc(len + 5);
    if(buffer)
    {
        memset(buffer, 0, len + 5);
        memcpy(buffer, buf, len);
        if((len % 4096) == 4095)
            len++;
        if((len % 4096) == 4094)
            pend = true;
        crc16 = rk_crc16(crc16, buffer, len);
        buffer[len++] = crc16 >> 8;
        buffer[len++] = crc16 & 0xff;
        while(total < len)
        {
            uint16_t n = ((len - total) > 4096) ? 4096 : uint16_t(len - total);
            if(libusb_control_transfer(m_handle, LIBUSB_REQUEST_TYPE_VENDOR, 0xc, 0, code, buffer + total, n, 0) != n)
            {
                free(buffer);
                return false;
            }
            total += n;
        }
        if(pend)
        {
            unsigned char zero = 0;
            libusb_control_transfer(m_handle, LIBUSB_REQUEST_TYPE_VENDOR, 0xc, 0, code, &zero, 1, 0);
        }
        free(buffer);
    }
    return true;
}


bool RK_usb::maskrom_upload_file(uint32_t code, const char* filename, bool rc4)
{
    uint64_t len;
    void* buffer = file_load(filename, &len);
    if(!buffer)
        return false;
    if(rc4)
        rk_rc4(buffer, len);
    bool ret = maskrom_upload_memory(code, buffer, len);
    free(buffer);
    return ret;
}


bool RK_usb::maskrom_dump_arm32(uint32_t uart, uint32_t addr, uint32_t len)
{
    static uint8_t payload[] =
    {
        0x00, 0x00, 0xA0, 0xE3, 0x17, 0x0F, 0x08, 0xEE, 0x15, 0x0F, 0x07, 0xEE, 0xD5, 0x0F, 0x07, 0xEE,
        0x9A, 0x0F, 0x07, 0xEE, 0x95, 0x0F, 0x07, 0xEE, 0x08, 0x00, 0x00, 0xEA, 0x00, 0x00, 0x4C, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x4F, 0xE2, 0x00, 0xD0, 0x80, 0xE5, 0x04, 0xE0, 0x80, 0xE5, 0x00, 0xE0, 0x0F, 0xE1,
        0x08, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x11, 0xEE, 0x0C, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x1C, 0xEE,
        0x10, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x11, 0xEE, 0x14, 0xE0, 0x80, 0xE5, 0x54, 0x00, 0x1F, 0xE5,
        0x58, 0x10, 0x1F, 0xE5, 0x58, 0x20, 0x1F, 0xE5, 0x13, 0x00, 0x00, 0xEB, 0x5C, 0x00, 0x4F, 0xE2,
        0x00, 0xD0, 0x90, 0xE5, 0x04, 0xE0, 0x90, 0xE5, 0x14, 0x10, 0x90, 0xE5, 0x10, 0x1F, 0x01, 0xEE,
        0x10, 0x10, 0x90, 0xE5, 0x10, 0x1F, 0x0C, 0xEE, 0x0C, 0x10, 0x90, 0xE5, 0x10, 0x1F, 0x01, 0xEE,
        0x08, 0x10, 0x90, 0xE5, 0x01, 0xF0, 0x29, 0xE1, 0x1E, 0xFF, 0x2F, 0xE1, 0x98, 0x10, 0x1F, 0xE5,
        0x7C, 0x20, 0x81, 0xE2, 0x00, 0x20, 0x92, 0xE5, 0x02, 0x20, 0x02, 0xE2, 0x00, 0x00, 0x52, 0xE3,
        0xFA, 0xFF, 0xFF, 0x0A, 0x00, 0x00, 0x81, 0xE5, 0x1E, 0xFF, 0x2F, 0xE1, 0xF8, 0x4F, 0x2D, 0xE9,
        0x00, 0x70, 0x52, 0xE2, 0xF8, 0x8F, 0xBD, 0xD8, 0x01, 0xA0, 0x47, 0xE2, 0x00, 0x90, 0xA0, 0xE1,
        0x0F, 0xA0, 0xCA, 0xE3, 0x01, 0x80, 0xA0, 0xE1, 0x10, 0x60, 0xA0, 0xE3, 0x20, 0xA0, 0x8A, 0xE2,
        0x16, 0x02, 0x79, 0xE3, 0x10, 0x50, 0x46, 0xE2, 0x29, 0x0E, 0xA0, 0xE1, 0x05, 0xB0, 0xA0, 0xE1,
        0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xE7, 0xFF, 0xFF, 0xEB, 0x59, 0x0C, 0xE3, 0xE7,
        0x09, 0x00, 0x50, 0xE3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xE2, 0xFF, 0xFF, 0xEB,
        0x59, 0x0A, 0xE3, 0xE7, 0x09, 0x00, 0x50, 0xE3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82,
        0xDD, 0xFF, 0xFF, 0xEB, 0x59, 0x08, 0xE3, 0xE7, 0x09, 0x00, 0x50, 0xE3, 0x30, 0x00, 0x80, 0x92,
        0x57, 0x00, 0x80, 0x82, 0xD8, 0xFF, 0xFF, 0xEB, 0x59, 0x06, 0xE3, 0xE7, 0x09, 0x00, 0x50, 0xE3,
        0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xD3, 0xFF, 0xFF, 0xEB, 0x59, 0x04, 0xE3, 0xE7,
        0x09, 0x00, 0x50, 0xE3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xCE, 0xFF, 0xFF, 0xEB,
        0x59, 0x02, 0xE3, 0xE7, 0x09, 0x00, 0x50, 0xE3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82,
        0xC9, 0xFF, 0xFF, 0xEB, 0x0F, 0x00, 0x09, 0xE2, 0x09, 0x00, 0x50, 0xE3, 0x30, 0x00, 0x80, 0x92,
        0x57, 0x00, 0x80, 0x82, 0xC4, 0xFF, 0xFF, 0xEB, 0x3A, 0x00, 0xA0, 0xE3, 0xC2, 0xFF, 0xFF, 0xEB,
        0x20, 0x00, 0xA0, 0xE3, 0xC0, 0xFF, 0xFF, 0xEB, 0x0F, 0x00, 0x00, 0xEA, 0x0B, 0x40, 0xD8, 0xE7,
        0x24, 0x32, 0xA0, 0xE1, 0x9F, 0x00, 0x54, 0xE3, 0x57, 0x00, 0x83, 0xE2, 0x0F, 0x40, 0x04, 0xE2,
        0x30, 0x00, 0x83, 0x92, 0xB8, 0xFF, 0xFF, 0xEB, 0x09, 0x00, 0x54, 0xE3, 0x57, 0x00, 0x84, 0xE2,
        0x30, 0x00, 0x84, 0x92, 0x01, 0xB0, 0x8B, 0xE2, 0xB3, 0xFF, 0xFF, 0xEB, 0x20, 0x00, 0xA0, 0xE3,
        0xB1, 0xFF, 0xFF, 0xEB, 0x0B, 0x00, 0x56, 0xE1, 0x05, 0x00, 0x00, 0x0A, 0x0B, 0x00, 0x57, 0xE1,
        0xED, 0xFF, 0xFF, 0xCA, 0x20, 0x00, 0xA0, 0xE3, 0xAB, 0xFF, 0xFF, 0xEB, 0x20, 0x00, 0xA0, 0xE3,
        0xF3, 0xFF, 0xFF, 0xEA, 0x7C, 0x00, 0xA0, 0xE3, 0xA7, 0xFF, 0xFF, 0xEB, 0x08, 0x00, 0x00, 0xEA,
        0x05, 0x30, 0xD8, 0xE7, 0x2E, 0x00, 0xA0, 0xE3, 0x01, 0x50, 0x85, 0xE2, 0x20, 0x20, 0x43, 0xE2,
        0x5E, 0x00, 0x52, 0xE3, 0x03, 0x00, 0xA0, 0x91, 0x9F, 0xFF, 0xFF, 0xEB, 0x05, 0x00, 0x56, 0xE1,
        0x06, 0x00, 0x00, 0x0A, 0x05, 0x00, 0x57, 0xE1, 0xF4, 0xFF, 0xFF, 0xCA, 0x20, 0x00, 0xA0, 0xE3,
        0x01, 0x50, 0x85, 0xE2, 0x98, 0xFF, 0xFF, 0xEB, 0x05, 0x00, 0x56, 0xE1, 0xF8, 0xFF, 0xFF, 0x1A,
        0x0D, 0x00, 0xA0, 0xE3, 0x10, 0x60, 0x86, 0xE2, 0x10, 0x90, 0x89, 0xE2, 0x92, 0xFF, 0xFF, 0xEB,
        0x0A, 0x00, 0xA0, 0xE3, 0x90, 0xFF, 0xFF, 0xEB, 0x06, 0x00, 0x5A, 0xE1, 0x9F, 0xFF, 0xFF, 0x1A,
        0xF8, 0x8F, 0xBD, 0xE8
    };

    put_unaligned_le32(&payload[0x1c], uart);
    put_unaligned_le32(&payload[0x20], addr);
    put_unaligned_le32(&payload[0x24], len);
    return maskrom_upload_memory(0x471, payload, sizeof(payload));
}

bool RK_usb::maskrom_dump_arm64(uint32_t uart, uint32_t addr, uint32_t len)
{
    static uint8_t payload[] =
    {
        0xDF, 0x3F, 0x03, 0xD5, 0x9F, 0x3F, 0x03, 0xD5, 0x0C, 0x00, 0x00, 0x14, 0x00, 0x00, 0xD4, 0x2A,
        0x00, 0x00, 0xFF, 0xFF, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x10, 0xE1, 0x03, 0x1E, 0xAA,
        0x01, 0x00, 0x00, 0xB9, 0xE1, 0x03, 0x1D, 0xAA, 0x01, 0x04, 0x00, 0xB9, 0xE1, 0x03, 0x1C, 0xAA,
        0x01, 0x08, 0x00, 0xB9, 0xE1, 0x03, 0x00, 0x91, 0x01, 0x0C, 0x00, 0xB9, 0xA0, 0xFD, 0xFF, 0x18,
        0x81, 0xFD, 0xFF, 0x18, 0x82, 0xFD, 0xFF, 0x18, 0x16, 0x00, 0x00, 0x94, 0xE1, 0x03, 0x1F, 0xAA,
        0x40, 0xFD, 0xFF, 0x10, 0x01, 0x00, 0x40, 0xB9, 0xFE, 0x03, 0x01, 0xAA, 0x01, 0x04, 0x40, 0xB9,
        0xFD, 0x03, 0x01, 0xAA, 0x01, 0x08, 0x40, 0xB9, 0xFC, 0x03, 0x01, 0xAA, 0x01, 0x0C, 0x40, 0xB9,
        0x3F, 0x00, 0x00, 0x91, 0x00, 0x00, 0x80, 0xD2, 0xC0, 0x03, 0x5F, 0xD6, 0x81, 0xFB, 0xFF, 0x18,
        0x22, 0xF0, 0x01, 0x91, 0x42, 0x00, 0x40, 0xB9, 0x42, 0x00, 0x1F, 0x12, 0x5F, 0x00, 0x00, 0x71,
        0x80, 0xFF, 0xFF, 0x54, 0x20, 0x00, 0x00, 0xF9, 0xC0, 0x03, 0x5F, 0xD6, 0x00, 0x00, 0x00, 0x00,
        0x5F, 0x00, 0x00, 0x71, 0xED, 0x11, 0x00, 0x54, 0xFD, 0x7B, 0xBA, 0xA9, 0xFD, 0x03, 0x00, 0x91,
        0xF9, 0x6B, 0x04, 0xA9, 0x5A, 0x04, 0x00, 0x51, 0x5A, 0x6F, 0x1C, 0x12, 0x5A, 0x43, 0x00, 0x11,
        0xF3, 0x53, 0x01, 0xA9, 0x34, 0x40, 0x00, 0x91, 0xF5, 0x5B, 0x02, 0xA9, 0xF6, 0x03, 0x02, 0x2A,
        0x19, 0x00, 0x80, 0x52, 0xF7, 0x63, 0x03, 0xA9, 0xF7, 0x03, 0x00, 0xAA, 0xF8, 0x03, 0x01, 0xAA,
        0xFB, 0x2B, 0x00, 0xF9, 0x1F, 0x20, 0x03, 0xD5, 0xE1, 0x7E, 0x1C, 0x53, 0xFB, 0x03, 0x18, 0xAA,
        0x3F, 0x24, 0x00, 0x71, 0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11, 0x35, 0x03, 0x18, 0x4B,
        0x20, 0x80, 0x80, 0x1A, 0xDE, 0xFF, 0xFF, 0x97, 0xE1, 0x6E, 0x18, 0x53, 0x3F, 0x24, 0x00, 0x71,
        0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1A, 0xD8, 0xFF, 0xFF, 0x97,
        0xE1, 0x5E, 0x14, 0x53, 0x3F, 0x24, 0x00, 0x71, 0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11,
        0x20, 0x80, 0x80, 0x1A, 0xD2, 0xFF, 0xFF, 0x97, 0xE1, 0x4E, 0x10, 0x53, 0x3F, 0x24, 0x00, 0x71,
        0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1A, 0xCC, 0xFF, 0xFF, 0x97,
        0xE1, 0x3E, 0x0C, 0x53, 0x3F, 0x24, 0x00, 0x71, 0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11,
        0x20, 0x80, 0x80, 0x1A, 0xC6, 0xFF, 0xFF, 0x97, 0xE1, 0x2E, 0x08, 0x53, 0x3F, 0x24, 0x00, 0x71,
        0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1A, 0xC0, 0xFF, 0xFF, 0x97,
        0xE1, 0x1E, 0x04, 0x53, 0x3F, 0x24, 0x00, 0x71, 0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11,
        0x20, 0x80, 0x80, 0x1A, 0xBA, 0xFF, 0xFF, 0x97, 0xE1, 0x0E, 0x00, 0x12, 0x3F, 0x24, 0x00, 0x71,
        0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1A, 0xB4, 0xFF, 0xFF, 0x97,
        0x40, 0x07, 0x80, 0x52, 0xB2, 0xFF, 0xFF, 0x97, 0x00, 0x04, 0x80, 0x52, 0xB0, 0xFF, 0xFF, 0x97,
        0x13, 0x00, 0x00, 0x14, 0x73, 0x03, 0x40, 0x39, 0x7B, 0x07, 0x00, 0x91, 0x61, 0x7E, 0x04, 0x53,
        0x3F, 0x24, 0x00, 0x71, 0x20, 0xC0, 0x00, 0x11, 0x21, 0x5C, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1A,
        0xA7, 0xFF, 0xFF, 0x97, 0x61, 0x0E, 0x00, 0x12, 0x3F, 0x24, 0x00, 0x71, 0x20, 0xC0, 0x00, 0x11,
        0x21, 0x5C, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1A, 0xA1, 0xFF, 0xFF, 0x97, 0x00, 0x04, 0x80, 0x52,
        0x9F, 0xFF, 0xFF, 0x97, 0x9F, 0x02, 0x1B, 0xEB, 0xA0, 0x01, 0x00, 0x54, 0xA0, 0x02, 0x1B, 0x0B,
        0xDF, 0x02, 0x00, 0x6B, 0x8C, 0xFD, 0xFF, 0x54, 0x00, 0x04, 0x80, 0x52, 0x98, 0xFF, 0xFF, 0x97,
        0x00, 0x04, 0x80, 0x52, 0x96, 0xFF, 0xFF, 0x97, 0x7B, 0x07, 0x00, 0x91, 0x00, 0x04, 0x80, 0x52,
        0x93, 0xFF, 0xFF, 0x97, 0x9F, 0x02, 0x1B, 0xEB, 0xA1, 0xFE, 0xFF, 0x54, 0x80, 0x0F, 0x80, 0x52,
        0xF3, 0x03, 0x18, 0xAA, 0x8E, 0xFF, 0xFF, 0x97, 0x06, 0x00, 0x00, 0x14, 0xE0, 0x03, 0x01, 0x2A,
        0x8B, 0xFF, 0xFF, 0x97, 0x73, 0x06, 0x00, 0x91, 0x9F, 0x02, 0x13, 0xEB, 0xA0, 0x01, 0x00, 0x54,
        0xA0, 0x02, 0x13, 0x0B, 0xDF, 0x02, 0x00, 0x6B, 0x6D, 0x03, 0x00, 0x54, 0x61, 0x02, 0x40, 0x39,
        0xC0, 0x05, 0x80, 0x52, 0x22, 0x80, 0x00, 0x51, 0x5F, 0x78, 0x01, 0x71, 0x89, 0xFE, 0xFF, 0x54,
        0x73, 0x06, 0x00, 0x91, 0x7E, 0xFF, 0xFF, 0x97, 0x9F, 0x02, 0x13, 0xEB, 0xA1, 0xFE, 0xFF, 0x54,
        0xA0, 0x01, 0x80, 0x52, 0x7A, 0xFF, 0xFF, 0x97, 0x39, 0x43, 0x00, 0x11, 0x40, 0x01, 0x80, 0x52,
        0x77, 0xFF, 0xFF, 0x97, 0xF7, 0x42, 0x00, 0x91, 0x3F, 0x03, 0x1A, 0x6B, 0x94, 0x42, 0x00, 0x91,
        0x18, 0x43, 0x00, 0x91, 0xA1, 0xF1, 0xFF, 0x54, 0xFB, 0x2B, 0x40, 0xF9, 0xF3, 0x53, 0x41, 0xA9,
        0xF5, 0x5B, 0x42, 0xA9, 0xF7, 0x63, 0x43, 0xA9, 0xF9, 0x6B, 0x44, 0xA9, 0xFD, 0x7B, 0xC6, 0xA8,
        0xC0, 0x03, 0x5F, 0xD6, 0x00, 0x04, 0x80, 0x52, 0x69, 0xFF, 0xFF, 0x97, 0xDE, 0xFF, 0xFF, 0x17,
        0xC0, 0x03, 0x5F, 0xD6
    };

    put_unaligned_le32(&payload[0x0c], uart);
    put_unaligned_le32(&payload[0x10], addr);
    put_unaligned_le32(&payload[0x14], len);
    return maskrom_upload_memory(0x471, payload, sizeof(payload));
}

bool RK_usb::maskrom_write_arm32(uint32_t addr, void* buf, size_t len)
{
    static const uint8_t payload[] =
    {
        0x00, 0x00, 0xA0, 0xE3, 0x17, 0x0F, 0x08, 0xEE, 0x15, 0x0F, 0x07, 0xEE, 0xD5, 0x0F, 0x07, 0xEE,
        0x9A, 0x0F, 0x07, 0xEE, 0x95, 0x0F, 0x07, 0xEE, 0x28, 0x01, 0x00, 0xEA, 0x00, 0x00, 0x51, 0xE1,
        0x91, 0x00, 0x00, 0x3A, 0x00, 0x00, 0xA0, 0x03, 0x0E, 0xF0, 0xA0, 0x01, 0x01, 0x40, 0x2D, 0xE9,
        0x04, 0x20, 0x52, 0xE2, 0x20, 0x00, 0x00, 0xBA, 0x03, 0xC0, 0x10, 0xE2, 0x28, 0x00, 0x00, 0x1A,
        0x03, 0xC0, 0x11, 0xE2, 0x32, 0x00, 0x00, 0x1A, 0x08, 0x20, 0x52, 0xE2, 0x12, 0x00, 0x00, 0xBA,
        0x14, 0x20, 0x52, 0xE2, 0x0B, 0x00, 0x00, 0xBA, 0x10, 0x00, 0x2D, 0xE9, 0x18, 0x50, 0xB1, 0xE8,
        0x18, 0x50, 0xA0, 0xE8, 0x18, 0x50, 0xB1, 0xE8, 0x18, 0x50, 0xA0, 0xE8, 0x20, 0x20, 0x52, 0xE2,
        0xF9, 0xFF, 0xFF, 0xAA, 0x10, 0x00, 0x72, 0xE3, 0x18, 0x50, 0xB1, 0xA8, 0x18, 0x50, 0xA0, 0xA8,
        0x10, 0x20, 0x42, 0xA2, 0x10, 0x00, 0xBD, 0xE8, 0x14, 0x20, 0x92, 0xE2, 0x08, 0x50, 0xB1, 0xA8,
        0x08, 0x50, 0xA0, 0xA8, 0x0C, 0x20, 0x52, 0xA2, 0xFB, 0xFF, 0xFF, 0xAA, 0x08, 0x20, 0x92, 0xE2,
        0x05, 0x00, 0x00, 0xBA, 0x04, 0x20, 0x52, 0xE2, 0x04, 0x30, 0x91, 0xB4, 0x04, 0x30, 0x80, 0xB4,
        0x08, 0x10, 0xB1, 0xA8, 0x08, 0x10, 0xA0, 0xA8, 0x04, 0x20, 0x42, 0xA2, 0x04, 0x20, 0x92, 0xE2,
        0x01, 0x80, 0xBD, 0x08, 0x02, 0x00, 0x52, 0xE3, 0x01, 0x30, 0xD1, 0xE4, 0x01, 0x30, 0xC0, 0xE4,
        0x01, 0x30, 0xD1, 0xA4, 0x01, 0x30, 0xC0, 0xA4, 0x01, 0x30, 0xD1, 0xC4, 0x01, 0x30, 0xC0, 0xC4,
        0x01, 0x80, 0xBD, 0xE8, 0x04, 0xC0, 0x6C, 0xE2, 0x02, 0x00, 0x5C, 0xE3, 0x01, 0x30, 0xD1, 0xE4,
        0x01, 0x30, 0xC0, 0xE4, 0x01, 0x30, 0xD1, 0xA4, 0x01, 0x30, 0xC0, 0xA4, 0x01, 0x30, 0xD1, 0xC4,
        0x01, 0x30, 0xC0, 0xC4, 0x0C, 0x20, 0x52, 0xE0, 0xEB, 0xFF, 0xFF, 0xBA, 0x03, 0xC0, 0x11, 0xE2,
        0xCC, 0xFF, 0xFF, 0x0A, 0x03, 0x10, 0xC1, 0xE3, 0x04, 0xE0, 0x91, 0xE4, 0x02, 0x00, 0x5C, 0xE3,
        0x36, 0x00, 0x00, 0xCA, 0x1A, 0x00, 0x00, 0x0A, 0x0C, 0x00, 0x52, 0xE3, 0x10, 0x00, 0x00, 0xBA,
        0x0C, 0x20, 0x42, 0xE2, 0x30, 0x00, 0x2D, 0xE9, 0x2E, 0x34, 0xA0, 0xE1, 0x30, 0x50, 0xB1, 0xE8,
        0x04, 0x3C, 0x83, 0xE1, 0x24, 0x44, 0xA0, 0xE1, 0x05, 0x4C, 0x84, 0xE1, 0x25, 0x54, 0xA0, 0xE1,
        0x0C, 0x5C, 0x85, 0xE1, 0x2C, 0xC4, 0xA0, 0xE1, 0x0E, 0xCC, 0x8C, 0xE1, 0x38, 0x10, 0xA0, 0xE8,
        0x10, 0x20, 0x52, 0xE2, 0xF3, 0xFF, 0xFF, 0xAA, 0x30, 0x00, 0xBD, 0xE8, 0x0C, 0x20, 0x92, 0xE2,
        0x05, 0x00, 0x00, 0xBA, 0x2E, 0xC4, 0xA0, 0xE1, 0x04, 0xE0, 0x91, 0xE4, 0x0E, 0xCC, 0x8C, 0xE1,
        0x04, 0xC0, 0x80, 0xE4, 0x04, 0x20, 0x52, 0xE2, 0xF9, 0xFF, 0xFF, 0xAA, 0x03, 0x10, 0x41, 0xE2,
        0xC9, 0xFF, 0xFF, 0xEA, 0x0C, 0x00, 0x52, 0xE3, 0x10, 0x00, 0x00, 0xBA, 0x0C, 0x20, 0x42, 0xE2,
        0x30, 0x00, 0x2D, 0xE9, 0x2E, 0x38, 0xA0, 0xE1, 0x30, 0x50, 0xB1, 0xE8, 0x04, 0x38, 0x83, 0xE1,
        0x24, 0x48, 0xA0, 0xE1, 0x05, 0x48, 0x84, 0xE1, 0x25, 0x58, 0xA0, 0xE1, 0x0C, 0x58, 0x85, 0xE1,
        0x2C, 0xC8, 0xA0, 0xE1, 0x0E, 0xC8, 0x8C, 0xE1, 0x38, 0x10, 0xA0, 0xE8, 0x10, 0x20, 0x52, 0xE2,
        0xF3, 0xFF, 0xFF, 0xAA, 0x30, 0x00, 0xBD, 0xE8, 0x0C, 0x20, 0x92, 0xE2, 0x05, 0x00, 0x00, 0xBA,
        0x2E, 0xC8, 0xA0, 0xE1, 0x04, 0xE0, 0x91, 0xE4, 0x0E, 0xC8, 0x8C, 0xE1, 0x04, 0xC0, 0x80, 0xE4,
        0x04, 0x20, 0x52, 0xE2, 0xF9, 0xFF, 0xFF, 0xAA, 0x02, 0x10, 0x41, 0xE2, 0xAE, 0xFF, 0xFF, 0xEA,
        0x0C, 0x00, 0x52, 0xE3, 0x10, 0x00, 0x00, 0xBA, 0x0C, 0x20, 0x42, 0xE2, 0x30, 0x00, 0x2D, 0xE9,
        0x2E, 0x3C, 0xA0, 0xE1, 0x30, 0x50, 0xB1, 0xE8, 0x04, 0x34, 0x83, 0xE1, 0x24, 0x4C, 0xA0, 0xE1,
        0x05, 0x44, 0x84, 0xE1, 0x25, 0x5C, 0xA0, 0xE1, 0x0C, 0x54, 0x85, 0xE1, 0x2C, 0xCC, 0xA0, 0xE1,
        0x0E, 0xC4, 0x8C, 0xE1, 0x38, 0x10, 0xA0, 0xE8, 0x10, 0x20, 0x52, 0xE2, 0xF3, 0xFF, 0xFF, 0xAA,
        0x30, 0x00, 0xBD, 0xE8, 0x0C, 0x20, 0x92, 0xE2, 0x05, 0x00, 0x00, 0xBA, 0x2E, 0xCC, 0xA0, 0xE1,
        0x04, 0xE0, 0x91, 0xE4, 0x0E, 0xC4, 0x8C, 0xE1, 0x04, 0xC0, 0x80, 0xE4, 0x04, 0x20, 0x52, 0xE2,
        0xF9, 0xFF, 0xFF, 0xAA, 0x01, 0x10, 0x41, 0xE2, 0x93, 0xFF, 0xFF, 0xEA, 0x02, 0x10, 0x81, 0xE0,
        0x02, 0x00, 0x80, 0xE0, 0x04, 0x20, 0x52, 0xE2, 0x1F, 0x00, 0x00, 0xBA, 0x03, 0xC0, 0x10, 0xE2,
        0x27, 0x00, 0x00, 0x1A, 0x03, 0xC0, 0x11, 0xE2, 0x30, 0x00, 0x00, 0x1A, 0x08, 0x20, 0x52, 0xE2,
        0x11, 0x00, 0x00, 0xBA, 0x10, 0x40, 0x2D, 0xE9, 0x14, 0x20, 0x52, 0xE2, 0x05, 0x00, 0x00, 0xBA,
        0x18, 0x50, 0x31, 0xE9, 0x18, 0x50, 0x20, 0xE9, 0x18, 0x50, 0x31, 0xE9, 0x18, 0x50, 0x20, 0xE9,
        0x20, 0x20, 0x52, 0xE2, 0xF9, 0xFF, 0xFF, 0xAA, 0x10, 0x00, 0x72, 0xE3, 0x18, 0x50, 0x31, 0xA9,
        0x18, 0x50, 0x20, 0xA9, 0x10, 0x20, 0x42, 0xA2, 0x14, 0x20, 0x92, 0xE2, 0x08, 0x50, 0x31, 0xA9,
        0x08, 0x50, 0x20, 0xA9, 0x0C, 0x20, 0x42, 0xA2, 0x10, 0x40, 0xBD, 0xE8, 0x08, 0x20, 0x92, 0xE2,
        0x05, 0x00, 0x00, 0xBA, 0x04, 0x20, 0x52, 0xE2, 0x04, 0x30, 0x31, 0xB5, 0x04, 0x30, 0x20, 0xB5,
        0x08, 0x10, 0x31, 0xA9, 0x08, 0x10, 0x20, 0xA9, 0x04, 0x20, 0x42, 0xA2, 0x04, 0x20, 0x92, 0xE2,
        0x0E, 0xF0, 0xA0, 0x01, 0x02, 0x00, 0x52, 0xE3, 0x01, 0x30, 0x71, 0xE5, 0x01, 0x30, 0x60, 0xE5,
        0x01, 0x30, 0x71, 0xA5, 0x01, 0x30, 0x60, 0xA5, 0x01, 0x30, 0x71, 0xC5, 0x01, 0x30, 0x60, 0xC5,
        0x0E, 0xF0, 0xA0, 0xE1, 0x02, 0x00, 0x5C, 0xE3, 0x01, 0x30, 0x71, 0xE5, 0x01, 0x30, 0x60, 0xE5,
        0x01, 0x30, 0x71, 0xA5, 0x01, 0x30, 0x60, 0xA5, 0x01, 0x30, 0x71, 0xC5, 0x01, 0x30, 0x60, 0xC5,
        0x0C, 0x20, 0x52, 0xE0, 0xEC, 0xFF, 0xFF, 0xBA, 0x03, 0xC0, 0x11, 0xE2, 0xCE, 0xFF, 0xFF, 0x0A,
        0x03, 0x10, 0xC1, 0xE3, 0x00, 0x30, 0x91, 0xE5, 0x02, 0x00, 0x5C, 0xE3, 0x36, 0x00, 0x00, 0xBA,
        0x1A, 0x00, 0x00, 0x0A, 0x0C, 0x00, 0x52, 0xE3, 0x10, 0x00, 0x00, 0xBA, 0x0C, 0x20, 0x42, 0xE2,
        0x30, 0x40, 0x2D, 0xE9, 0x03, 0xE4, 0xA0, 0xE1, 0x38, 0x10, 0x31, 0xE9, 0x2C, 0xEC, 0x8E, 0xE1,
        0x0C, 0xC4, 0xA0, 0xE1, 0x25, 0xCC, 0x8C, 0xE1, 0x05, 0x54, 0xA0, 0xE1, 0x24, 0x5C, 0x85, 0xE1,
        0x04, 0x44, 0xA0, 0xE1, 0x23, 0x4C, 0x84, 0xE1, 0x30, 0x50, 0x20, 0xE9, 0x10, 0x20, 0x52, 0xE2,
        0xF3, 0xFF, 0xFF, 0xAA, 0x30, 0x40, 0xBD, 0xE8, 0x0C, 0x20, 0x92, 0xE2, 0x05, 0x00, 0x00, 0xBA,
        0x03, 0xC4, 0xA0, 0xE1, 0x04, 0x30, 0x31, 0xE5, 0x23, 0xCC, 0x8C, 0xE1, 0x04, 0xC0, 0x20, 0xE5,
        0x04, 0x20, 0x52, 0xE2, 0xF9, 0xFF, 0xFF, 0xAA, 0x03, 0x10, 0x81, 0xE2, 0xCA, 0xFF, 0xFF, 0xEA,
        0x0C, 0x00, 0x52, 0xE3, 0x10, 0x00, 0x00, 0xBA, 0x0C, 0x20, 0x42, 0xE2, 0x30, 0x40, 0x2D, 0xE9,
        0x03, 0xE8, 0xA0, 0xE1, 0x38, 0x10, 0x31, 0xE9, 0x2C, 0xE8, 0x8E, 0xE1, 0x0C, 0xC8, 0xA0, 0xE1,
        0x25, 0xC8, 0x8C, 0xE1, 0x05, 0x58, 0xA0, 0xE1, 0x24, 0x58, 0x85, 0xE1, 0x04, 0x48, 0xA0, 0xE1,
        0x23, 0x48, 0x84, 0xE1, 0x30, 0x50, 0x20, 0xE9, 0x10, 0x20, 0x52, 0xE2, 0xF3, 0xFF, 0xFF, 0xAA,
        0x30, 0x40, 0xBD, 0xE8, 0x0C, 0x20, 0x92, 0xE2, 0x05, 0x00, 0x00, 0xBA, 0x03, 0xC8, 0xA0, 0xE1,
        0x04, 0x30, 0x31, 0xE5, 0x23, 0xC8, 0x8C, 0xE1, 0x04, 0xC0, 0x20, 0xE5, 0x04, 0x20, 0x52, 0xE2,
        0xF9, 0xFF, 0xFF, 0xAA, 0x02, 0x10, 0x81, 0xE2, 0xAF, 0xFF, 0xFF, 0xEA, 0x0C, 0x00, 0x52, 0xE3,
        0x10, 0x00, 0x00, 0xBA, 0x0C, 0x20, 0x42, 0xE2, 0x30, 0x40, 0x2D, 0xE9, 0x03, 0xEC, 0xA0, 0xE1,
        0x38, 0x10, 0x31, 0xE9, 0x2C, 0xE4, 0x8E, 0xE1, 0x0C, 0xCC, 0xA0, 0xE1, 0x25, 0xC4, 0x8C, 0xE1,
        0x05, 0x5C, 0xA0, 0xE1, 0x24, 0x54, 0x85, 0xE1, 0x04, 0x4C, 0xA0, 0xE1, 0x23, 0x44, 0x84, 0xE1,
        0x30, 0x50, 0x20, 0xE9, 0x10, 0x20, 0x52, 0xE2, 0xF3, 0xFF, 0xFF, 0xAA, 0x30, 0x40, 0xBD, 0xE8,
        0x0C, 0x20, 0x92, 0xE2, 0x05, 0x00, 0x00, 0xBA, 0x03, 0xCC, 0xA0, 0xE1, 0x04, 0x30, 0x31, 0xE5,
        0x23, 0xC4, 0x8C, 0xE1, 0x04, 0xC0, 0x20, 0xE5, 0x04, 0x20, 0x52, 0xE2, 0xF9, 0xFF, 0xFF, 0xAA,
        0x01, 0x10, 0x81, 0xE2, 0x94, 0xFF, 0xFF, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x4F, 0xE2, 0x00, 0xD0, 0x80, 0xE5, 0x04, 0xE0, 0x80, 0xE5, 0x00, 0xE0, 0x0F, 0xE1,
        0x08, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x11, 0xEE, 0x0C, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x1C, 0xEE,
        0x10, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x11, 0xEE, 0x14, 0xE0, 0x80, 0xE5, 0x54, 0x00, 0x8F, 0xE2,
        0x48, 0x10, 0x9F, 0xE5, 0x01, 0x00, 0x50, 0xE1, 0x03, 0x00, 0x00, 0x0A, 0x3C, 0x00, 0x9F, 0xE5,
        0x40, 0x10, 0x8F, 0xE2, 0x38, 0x20, 0x9F, 0xE5, 0xC3, 0xFE, 0xFF, 0xEB, 0x00, 0x00, 0xA0, 0xE1,
        0x70, 0x00, 0x4F, 0xE2, 0x00, 0xD0, 0x90, 0xE5, 0x04, 0xE0, 0x90, 0xE5, 0x14, 0x10, 0x90, 0xE5,
        0x10, 0x1F, 0x01, 0xEE, 0x10, 0x10, 0x90, 0xE5, 0x10, 0x1F, 0x0C, 0xEE, 0x0C, 0x10, 0x90, 0xE5,
        0x10, 0x1F, 0x01, 0xEE, 0x08, 0x10, 0x90, 0xE5, 0x01, 0xF0, 0x29, 0xE1, 0x1E, 0xFF, 0x2F, 0xE1
       // +prog_address_uit32   +prog_size_uit32  +prog_data_xxx 
    };

    uint8_t* tmp = (uint8_t*)malloc(sizeof(payload) + 8 + len);
    memcpy(&tmp[0], &payload[0], sizeof(payload));
    put_unaligned_le32(tmp + sizeof(payload) + 0, addr);
    put_unaligned_le32(tmp + sizeof(payload) + 4, (uint32_t)len);
    memcpy(tmp + sizeof(payload) + 8, buf, len);
    bool ret = maskrom_upload_memory(0x471, tmp, sizeof(payload) + 8 + len);
    free(tmp);
    return ret;
}

bool RK_usb::maskrom_write_arm64(uint32_t addr, void* buf, size_t len)
{
    static const uint8_t payload[] =
    {
        0xDF, 0x3F, 0x03, 0xD5, 0x9F, 0x3F, 0x03, 0xD5, 0x44, 0x00, 0x00, 0x14, 0xFF, 0xC3, 0x00, 0xD1,
        0xE0, 0x0F, 0x00, 0xF9, 0xE1, 0x0B, 0x00, 0xF9, 0xE2, 0x07, 0x00, 0xF9, 0xE1, 0x0F, 0x40, 0xF9,
        0xE0, 0x0B, 0x40, 0xF9, 0x3F, 0x00, 0x00, 0xEB, 0x88, 0x02, 0x00, 0x54, 0xE0, 0x0F, 0x40, 0xF9,
        0xE0, 0x13, 0x00, 0xF9, 0xE0, 0x0B, 0x40, 0xF9, 0xE0, 0x17, 0x00, 0xF9, 0x09, 0x00, 0x00, 0x14,
        0xE1, 0x17, 0x40, 0xF9, 0x20, 0x04, 0x00, 0x91, 0xE0, 0x17, 0x00, 0xF9, 0xE0, 0x13, 0x40, 0xF9,
        0x02, 0x04, 0x00, 0x91, 0xE2, 0x13, 0x00, 0xF9, 0x21, 0x00, 0x40, 0x39, 0x01, 0x00, 0x00, 0x39,
        0xE0, 0x07, 0x40, 0xF9, 0x01, 0x04, 0x00, 0xD1, 0xE1, 0x07, 0x00, 0xF9, 0x1F, 0x00, 0x00, 0xF1,
        0x81, 0xFE, 0xFF, 0x54, 0x1D, 0x00, 0x00, 0x14, 0xE0, 0x0F, 0x40, 0xF9, 0xE0, 0x13, 0x00, 0xF9,
        0xE1, 0x13, 0x40, 0xF9, 0xE0, 0x07, 0x40, 0xF9, 0x20, 0x00, 0x00, 0x8B, 0xE0, 0x13, 0x00, 0xF9,
        0xE0, 0x0B, 0x40, 0xF9, 0xE0, 0x17, 0x00, 0xF9, 0xE1, 0x17, 0x40, 0xF9, 0xE0, 0x07, 0x40, 0xF9,
        0x20, 0x00, 0x00, 0x8B, 0xE0, 0x17, 0x00, 0xF9, 0x0B, 0x00, 0x00, 0x14, 0xE0, 0x17, 0x40, 0xF9,
        0x00, 0x04, 0x00, 0xD1, 0xE0, 0x17, 0x00, 0xF9, 0xE0, 0x13, 0x40, 0xF9, 0x00, 0x04, 0x00, 0xD1,
        0xE0, 0x13, 0x00, 0xF9, 0xE0, 0x17, 0x40, 0xF9, 0x01, 0x00, 0x40, 0x39, 0xE0, 0x13, 0x40, 0xF9,
        0x01, 0x00, 0x00, 0x39, 0xE0, 0x07, 0x40, 0xF9, 0x01, 0x04, 0x00, 0xD1, 0xE1, 0x07, 0x00, 0xF9,
        0x1F, 0x00, 0x00, 0xF1, 0x41, 0xFE, 0xFF, 0x54, 0xE0, 0x0F, 0x40, 0xF9, 0xFF, 0xC3, 0x00, 0x91,
        0xC0, 0x03, 0x5F, 0xD6, 0x1F, 0x20, 0x03, 0xD5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x10, 0xE1, 0x03, 0x1E, 0xAA,
        0x01, 0x00, 0x00, 0xB9, 0xE1, 0x03, 0x1D, 0xAA, 0x01, 0x04, 0x00, 0xB9, 0xE1, 0x03, 0x1C, 0xAA,
        0x01, 0x08, 0x00, 0xB9, 0xE1, 0x03, 0x00, 0x91, 0x01, 0x0C, 0x00, 0xB9, 0xE0, 0x02, 0x00, 0x10,
        0x81, 0x02, 0x00, 0x18, 0x1F, 0x00, 0x01, 0xEB, 0xA0, 0x00, 0x00, 0x54, 0x20, 0x02, 0x00, 0x18,
        0x41, 0x02, 0x00, 0x10, 0x02, 0x02, 0x00, 0x18, 0xAD, 0xFF, 0xFF, 0x97, 0x1F, 0x20, 0x03, 0xD5,
        0xE1, 0x03, 0x1F, 0xAA, 0xA0, 0xFC, 0xFF, 0x10, 0x01, 0x00, 0x40, 0xB9, 0xFE, 0x03, 0x01, 0xAA,
        0x01, 0x04, 0x40, 0xB9, 0xFD, 0x03, 0x01, 0xAA, 0x01, 0x08, 0x40, 0xB9, 0xFC, 0x03, 0x01, 0xAA,
        0x01, 0x0C, 0x40, 0xB9, 0x3F, 0x00, 0x00, 0x91, 0x00, 0x00, 0x80, 0xD2, 0xC0, 0x03, 0x5F, 0xD6
        // +prog_address_uit32   +prog_size_uit32  +prog_data_xxx  
    };

    uint8_t* tmp = (uint8_t*)malloc(sizeof(payload) + 8 + len);
    memcpy(&tmp[0], &payload[0], sizeof(payload));
    put_unaligned_le32(tmp + sizeof(payload) + 0, addr);
    put_unaligned_le32(tmp + sizeof(payload) + 4, (uint32_t)len);
    memcpy(tmp + sizeof(payload) + 8, buf, len);
    bool ret = maskrom_upload_memory(0x471, tmp, sizeof(payload) + 8 + len);
    free(tmp);
    return ret;
}

bool RK_usb::maskrom_write_arm32_progress(uint32_t addr, void* buf, size_t len)
{
    progress_t progress(len);
    while(len > 0)
    {
        size_t n = len > 16384 ? 16384 : len;
        if(!maskrom_write_arm32(addr, buf, n))
        {
            progress.stop();
            return false;
        }
        addr += (uint32_t)n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::maskrom_write_arm64_progress(uint32_t addr, void* buf, size_t len)
{
    progress_t progress(len);
    while(len > 0)
    {
        size_t n = len > 16384 ? 16384 : len;
        if(!maskrom_write_arm64(addr, buf, n))
        {
            progress.stop();
            return false;
        }
        addr += (uint32_t)n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::maskrom_exec_arm32(uint32_t addr)
{
    static uint8_t payload[] =
    {
        0x00, 0x00, 0xA0, 0xE3, 0x17, 0x0F, 0x08, 0xEE, 0x15, 0x0F, 0x07, 0xEE, 0xD5, 0x0F, 0x07, 0xEE,
        0x9A, 0x0F, 0x07, 0xEE, 0x95, 0x0F, 0x07, 0xEE, 0x06, 0x00, 0x00, 0xEA, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x4F, 0xE2, 0x00, 0xD0, 0x80, 0xE5,
        0x04, 0xE0, 0x80, 0xE5, 0x00, 0xE0, 0x0F, 0xE1, 0x08, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x11, 0xEE,
        0x0C, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x1C, 0xEE, 0x10, 0xE0, 0x80, 0xE5, 0x10, 0xEF, 0x11, 0xEE,
        0x14, 0xE0, 0x80, 0xE5, 0x00, 0x00, 0xA0, 0xE3, 0x00, 0x10, 0xA0, 0xE3, 0x58, 0x20, 0x1F, 0xE5,
        0x02, 0xF0, 0xA0, 0xE1, 0x5C, 0x00, 0x4F, 0xE2, 0x00, 0xD0, 0x90, 0xE5, 0x04, 0xE0, 0x90, 0xE5,
        0x14, 0x10, 0x90, 0xE5, 0x10, 0x1F, 0x01, 0xEE, 0x10, 0x10, 0x90, 0xE5, 0x10, 0x1F, 0x0C, 0xEE,
        0x0C, 0x10, 0x90, 0xE5, 0x10, 0x1F, 0x01, 0xEE, 0x08, 0x10, 0x90, 0xE5, 0x01, 0xF0, 0x29, 0xE1,
        0x1E, 0xFF, 0x2F, 0xE1
    };

    put_unaligned_le32(&payload[0x1c], addr);
    return maskrom_upload_memory(0x471, payload, sizeof(payload));
}

bool RK_usb::maskrom_exec_arm64(uint32_t addr)
{
    static uint8_t payload[] =
    {
        0xDF, 0x3F, 0x03, 0xD5, 0x9F, 0x3F, 0x03, 0xD5, 0x0A, 0x00, 0x00, 0x14, 0x44, 0x33, 0x22, 0x11,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xFF, 0xFF, 0x10, 0xE1, 0x03, 0x1E, 0xAA, 0x01, 0x00, 0x00, 0xB9, 0xE1, 0x03, 0x1D, 0xAA,
        0x01, 0x04, 0x00, 0xB9, 0xE1, 0x03, 0x1C, 0xAA, 0x01, 0x08, 0x00, 0xB9, 0xE1, 0x03, 0x00, 0x91,
        0x01, 0x0C, 0x00, 0xB9, 0xE0, 0x03, 0x1F, 0xAA, 0xE1, 0x03, 0x1F, 0xAA, 0x82, 0xFD, 0xFF, 0x18,
        0x40, 0x00, 0x1F, 0xD6, 0xE1, 0x03, 0x1F, 0xAA, 0x40, 0xFD, 0xFF, 0x10, 0x01, 0x00, 0x40, 0xB9,
        0xFE, 0x03, 0x01, 0xAA, 0x01, 0x04, 0x40, 0xB9, 0xFD, 0x03, 0x01, 0xAA, 0x01, 0x08, 0x40, 0xB9,
        0xFC, 0x03, 0x01, 0xAA, 0x01, 0x0C, 0x40, 0xB9, 0x3F, 0x00, 0x00, 0x91, 0x00, 0x00, 0x80, 0xD2,
        0xC0, 0x03, 0x5F, 0xD6
    };

    put_unaligned_le32(&payload[0x0c], addr);
    return maskrom_upload_memory(0x471, payload, sizeof(payload));
}

enum {
    USB_REQUEST_SIGN  = 0x55534243, // 'USBC'
    USB_RESPONSE_SIGN = 0x55534253, // 'USBS'
};

enum {
    USB_DIRECTION_OUT = 0x00,
    USB_DIRECTION_IN  = 0x80,
};

enum {
    OPCODE_TEST_UNIT_READY      = 0x00,
    OPCODE_READ_FLASH_ID        = 0x01,
    OPCODE_SET_DEVICE_ID        = 0x02,
    OPCODE_TEST_BAD_BLOCK       = 0x03,
    OPCODE_READ_SECTOR          = 0x04,
    OPCODE_WRITE_SECTOR         = 0x05,
    OPCODE_ERASE_NORMAL         = 0x06,
    OPCODE_WRITE_SPARE          = 0x07,
    OPCODE_READ_SPARE           = 0x08,
    OPCODE_ERASE_FORCE          = 0x0b,
    OPCODE_GET_VERSION          = 0x0c,
    OPCODE_READ_LBA             = 0x14,
    OPCODE_WRITE_LBA            = 0x15,
    OPCODE_ERASE_SYSDISK        = 0x16,
    OPCODE_READ_SDRAM           = 0x17,
    OPCODE_WRITE_SDRAM          = 0x18,
    OPCODE_EXEC_SDRAM           = 0x19,
    OPCODE_READ_FLASH_INFO      = 0x1a,
    OPCODE_READ_CHIP_INFO       = 0x1b,
    OPCODE_LOW_FORMAT           = 0x1c,
    OPCODE_SET_RESET_FLAG       = 0x1e,
    OPCODE_WRITE_EFUSE          = 0x1f,
    OPCODE_READ_EFUSE           = 0x20,
    OPCODE_READ_SPI_FLASH       = 0x21,
    OPCODE_WRITE_SPI_FLASH      = 0x22,
    OPCODE_WRITE_NEW_EFUSE      = 0x23,
    OPCODE_READ_NEW_EFUSE       = 0x24,
    OPCODE_ERASE_LBA            = 0x25,
    OPCODE_WRITE_VENDOR_STORAGE = 0x26,
    OPCODE_READ_VENDOR_STORAGE  = 0x27,
    OPCODE_READ_COM_LOG         = 0x28,
    OPCODE_SWITCH_STORAGE       = 0x2a,
    OPCODE_READ_STORAGE         = 0x2b,
    OPCODE_READ_OTP_CHIP        = 0x2c,
    OPCODE_SESSION              = 0x30,
    OPCODE_READ_CAPABILITY      = 0xaa,
    OPCODE_SWITCH_USB3          = 0xbb,
    OPCODE_RESET_DEVICE         = 0xff,
};

#pragma pack(push, 1)

struct usb_command_t
{
    uint8_t opcode;
    uint8_t subcode;
    uint8_t address[4];
    uint8_t reserved6;
    uint8_t size[2];
    uint8_t reserved9;
    uint8_t reserved10;
    uint8_t reserved11;
    uint8_t reserved12[4];
};

struct usb_request_t
{
    uint8_t signature[4]; // Contains 'USBC'
    uint8_t tag[4];       // The random unique id
    uint8_t length[4];    // The data transfer length
    uint8_t flag;         // Direction in bit 7, IN(0x80), OUT(0x00)
    uint8_t lun;          // Lun (Flash chip select, normally 0)
    uint8_t cmdlen;       // Command Length 6/10/16
    usb_command_t cmd;
};

struct usb_response_t
{
    uint8_t signature[4]; // Contains 'USBS'
    uint8_t tag[4];       // Same as original command
    uint8_t residue[4];   // Amount not transferred
    uint8_t status;       // Response status
};

#pragma pack(pop)


bool RK_usb::usb_bulk_send(void* buf, size_t len)
{
    const size_t max_chunk = 128 * 1024;
    int bytes;
    while(len > 0)
    {
        int chunk = len < max_chunk ? (int)len : max_chunk;
        if(libusb_bulk_transfer(m_handle, m_epout, (uint8_t*)buf, chunk, &bytes, 2000) != 0)
        {
            printf("usb bulk send error\r\n");
            return false;
        }
        len -= bytes;
        buf = (uint8_t*)buf + bytes;
    }
    return true;
}

bool RK_usb::usb_bulk_recv(void* buf, size_t len)
{
    int bytes;
    while(len > 0)
    {
        if(libusb_bulk_transfer(m_handle, m_epin, (uint8_t*)buf, int(len), &bytes, 2000) != 0)
        {
            printf("usb bulk recv error\r\n");
            return false;
        }
        len -= bytes;
        buf = (uint8_t*)buf + bytes;
    }
    return true;
}

static inline uint32_t make_tag()
{
    uint32_t tag = 0;
    for(size_t i = 0; i < 4; i++)
        tag = (tag << 8) | (rand() & 0xff);
    return tag;
}

bool RK_usb::chip_ready()
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_TEST_UNIT_READY;
    req.cmd.subcode = 0;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::version(uint8_t* buf_16)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 16);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_CHIP_INFO;

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
       return false;
    if(!usb_bulk_recv(buf_16, 16))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::capability(uint8_t* buf)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 8);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_CAPABILITY;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, 8))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::capability_support(enum capability_type_t type)
{
    uint8_t buf[8] = { 0 };

    if(capability(buf))
    {
        switch(type)
        {
        case CAPABILITY_TYPE_DIRECT_LBA:
            return (buf[0] & (1 << 0)) ? true : false;
        case CAPABILITY_TYPE_VENDOR_STORAGE:
            return (buf[0] & (1 << 1)) ? true : false;
        case CAPABILITY_TYPE_FIRST_4M_ACCESS:
            return (buf[0] & (1 << 2)) ? true : false;
        case CAPABILITY_TYPE_READ_LBA:
            return (buf[0] & (1 << 3)) ? true : false;
        case CAPABILITY_TYPE_NEW_VENDOR_STORAGE:
            return (buf[0] & (1 << 4)) ? true : false;
        case CAPABILITY_TYPE_READ_COM_LOG:
            return (buf[0] & (1 << 5)) ? true : false;
        case CAPABILITY_TYPE_READ_IDB_CONFIG:
            return (buf[0] & (1 << 6)) ? true : false;
        case CAPABILITY_TYPE_READ_SECURE_MODE:
            return (buf[0] & (1 << 7)) ? true : false;
        case CAPABILITY_TYPE_NEW_IDB:
            return (buf[1] & (1 << 0)) ? true : false;
        case CAPABILITY_TYPE_SWITCH_STORAGE:
            return (buf[1] & (1 << 1)) ? true : false;
        case CAPABILITY_TYPE_LBA_PARITY:
            return (buf[1] & (1 << 2)) ? true : false;
        case CAPABILITY_TYPE_READ_OTP_CHIP:
            return (buf[1] & (1 << 3)) ? true : false;
        case CAPABILITY_TYPE_SWITCH_USB3:
            return (buf[1] & (1 << 4)) ? true : false;
        default:
            break;
        }
    }
    return false;
}

bool RK_usb::reset(bool maskrom)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_RESET_DEVICE;
    req.cmd.subcode = maskrom ? 0x03 : 0x00;

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
    {
        libusb_reset_device(m_handle);
        return false;
    }
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::exec(uint32_t addr, uint32_t dtb)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_EXEC_SDRAM;
    req.cmd.subcode = 0xaa;
    put_unaligned_be32(&req.cmd.address[0], (uint32_t)addr);
    put_unaligned_be32(&req.cmd.size[0], (uint32_t)dtb);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::read_raw(uint32_t addr, void* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_READ_SDRAM;
    put_unaligned_be32(&req.cmd.address[0], addr);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)len);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::write_raw(uint32_t addr, void* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;
    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_WRITE_SDRAM;
    put_unaligned_be32(&req.cmd.address[0], addr);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)len);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_send(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::read(uint32_t addr, void* buf, size_t len)
{
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!read_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
    }
    return true;
}

bool RK_usb::write(uint32_t addr, void* buf, size_t len)
{
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!write_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
    }
    return true;
}

bool RK_usb::read_progress(uint32_t addr, void* buf, size_t len)
{
    progress_t progress(len);
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!read_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::write_progress(uint32_t addr, void* buf, size_t len)
{
    progress_t progress(len);
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!write_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::otp_read(uint8_t* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], uint32_t(len));
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_OTP_CHIP;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::sn_read(char* sn)
{
    if(sn)
    {
        char buf[2048];
        if(flash_read_lba(0xfff00001, 1, buf))
        {
            uint32_t valid = get_unaligned_le32(&buf[0]);
            uint32_t len = get_unaligned_le32(&buf[4]);
            if((valid == 1) && (len >= 0) && (len <= 512 - 8))
            {
                memcpy(sn, &buf[8], len);
                sn[len] = '\0';
                return true;
            }
        }
    }
    return false;
}

bool RK_usb::sn_write(char* sn)
{
    if(sn)
    {
        size_t len = strlen(sn);
        if((len >= 0) && (len <= 512 - 8))
        {
            char buf[512];
            memset(buf, 0, sizeof(buf));
            put_unaligned_le32(&buf[0], 1);
            put_unaligned_le32(&buf[4], uint32_t(len));
            memcpy(&buf[8], sn, len);
            return flash_write_lba(0xfff00001, 1, buf);
        }
    }
    return false;
}

bool RK_usb::vs_read(uint16_t type, uint16_t index, uint8_t* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], uint32_t(len));
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_READ_VENDOR_STORAGE;
    req.cmd.subcode = 0;
    put_unaligned_be16(&req.cmd.address[0], index);
    put_unaligned_be16(&req.cmd.address[2], type);
    put_unaligned_be16(&req.cmd.size[0], uint32_t(len));

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::vs_write(uint16_t type, uint16_t index, uint8_t* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], uint32_t(len));
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_WRITE_VENDOR_STORAGE;
    req.cmd.subcode = 0;
    put_unaligned_be16(&req.cmd.address[0], index);
    put_unaligned_be16(&req.cmd.address[2], type);
    put_unaligned_be16(&req.cmd.size[0], uint32_t(len));

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_send(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

enum storage_type_t RK_usb::storage_read()
{
    usb_request_t req;
    usb_response_t res;
    uint8_t buf[4];

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 4);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_STORAGE;

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return STORAGE_TYPE_UNKNOWN;
    if(!usb_bulk_recv(buf, 4))
        return STORAGE_TYPE_UNKNOWN;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return STORAGE_TYPE_UNKNOWN;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return STORAGE_TYPE_UNKNOWN;
    enum storage_type_t type = (enum storage_type_t)get_unaligned_le32(buf);
    switch(type)
    {
    case STORAGE_TYPE_FLASH:
    case STORAGE_TYPE_EMMC:
    case STORAGE_TYPE_SD:
    case STORAGE_TYPE_SD1:
    case STORAGE_TYPE_SPINOR:
    case STORAGE_TYPE_SPINAND:
    case STORAGE_TYPE_RAM:
    case STORAGE_TYPE_USB:
    case STORAGE_TYPE_SATA:
    case STORAGE_TYPE_PCIE:
        break;
    default:
        type = STORAGE_TYPE_UNKNOWN;
        break;
    }
    return type;
}

bool RK_usb::storage_switch(enum storage_type_t type)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_SWITCH_STORAGE;
    switch(type)
    {
        case STORAGE_TYPE_FLASH: req.cmd.subcode = 0; break;
        case STORAGE_TYPE_EMMC:  req.cmd.subcode = 1; break;
        case STORAGE_TYPE_SD:    req.cmd.subcode = 2; break;
        case STORAGE_TYPE_SD1:   req.cmd.subcode = 3; break;
        case STORAGE_TYPE_SPINOR:req.cmd.subcode = 9; break;
        case STORAGE_TYPE_SPINAND:req.cmd.subcode = 8;break;
        case STORAGE_TYPE_RAM:   req.cmd.subcode = 6; break;
        case STORAGE_TYPE_USB:   req.cmd.subcode = 7; break;
        case STORAGE_TYPE_SATA:  req.cmd.subcode = 10;break;
        case STORAGE_TYPE_PCIE:  req.cmd.subcode = 11;break;
        default: break;
    }
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::flash_detect(flash_info_t* info)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 11);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_FLASH_INFO;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(info, 11))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 5);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_FLASH_ID;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&info->id[0], 5))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::flash_erase_lba_raw(uint32_t sec, uint32_t cnt)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_ERASE_LBA;
    put_unaligned_be32(&req.cmd.address[0], sec);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)cnt);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}


bool RK_usb::flash_read_lba_raw(uint32_t sec, uint32_t cnt, void* buf)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], cnt << 9);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_READ_LBA;
    req.cmd.subcode = 0;
    put_unaligned_be32(&req.cmd.address[0], sec);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)cnt);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, cnt << 9))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::flash_write_lba_raw(uint32_t sec, uint32_t cnt, void* buf)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], cnt << 9);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_WRITE_LBA;
    req.cmd.subcode = 0;
    put_unaligned_be32(&req.cmd.address[0], sec);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)cnt);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_send(buf, cnt << 9))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if(get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN)
        return false;
    return true;
}

bool RK_usb::flash_erase_lba(uint32_t sec, uint32_t cnt)
{
    while(cnt > 0)
    {
        uint32_t n = cnt > 16384 ? 16384 : cnt;
        if(!flash_erase_lba_raw(sec, n))
            return false;
        sec += n;
        cnt -= n;
    }
    return true;
}

bool RK_usb::flash_read_lba(uint32_t sec, uint32_t cnt, void* buf)
{
    while(cnt > 0)
    {
        uint32_t n = cnt > 16384 ? 16384 : cnt;
        if(!flash_read_lba_raw(sec, n, buf))
            return false;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
    }
    return true;
}

bool RK_usb::flash_write_lba(uint32_t sec, uint32_t cnt, void* buf)
{
    while(cnt > 0)
    {
        uint32_t n = cnt > 16384 ? 16384 : cnt;
        if(!flash_write_lba_raw(sec, n, buf))
            return false;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
    }
    return true;
}

bool RK_usb::flash_erase_lba_progress(uint32_t sec, uint32_t cnt)
{
    uint32_t MAXSEC = 16384;
    if(cnt <= 65536)
        MAXSEC = 128;

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        if(!flash_erase_lba_raw(sec, n))
            return false;
        sec += n;
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    return true;
}

bool RK_usb::flash_read_lba_progress(uint32_t sec, uint32_t cnt, void* buf)
{
    uint32_t MAXSEC = 16384;
    if(cnt <= 65536)
        MAXSEC = 128;

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        if(!flash_read_lba_raw(sec, n, buf))
            return false;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    return true;
}

bool RK_usb::flash_write_lba_progress(uint32_t sec, uint32_t cnt, void* buf)
{
    uint32_t MAXSEC = 16384;
    progress_t progress((uint64_t)cnt << 9);

    if(cnt <= 65536)
        MAXSEC = 128;
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        if(!flash_write_lba_raw(sec, n, buf))
            return 0;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    return true;
}

bool RK_usb::flash_read_lba_to_file_progress(uint32_t sec, uint32_t cnt, const char* filename)
{
    uint32_t MAXSEC = 16384;

    FILE* f = fopen(filename, "wb");
    if(!f)
        return false;

    if(cnt <= 65536)
        MAXSEC = 128;

    void* buf = malloc(MAXSEC << 9);
    if(!buf)
    {
        fclose(f);
        return false;
    }

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        memset(buf, 0, MAXSEC << 9);
        if(!flash_read_lba_raw(sec, n, buf))
        {
            free(buf);
            fclose(f);
            return false;
        }
        if(fwrite(buf, 512, n, f) != n)
        {
            free(buf);
            fclose(f);
            return false;
        }
        sec += n;
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();

    free(buf);
    fclose(f);
    return true;
}

bool RK_usb::flash_write_lba_from_file_progress(uint32_t sec, uint32_t maxcnt, const char* filename)
{
    uint32_t MAXSEC = 16384;

    FILE* f = fopen(filename, "rb");
    if(!f)
        return false;

    fseek(f, 0, SEEK_END);
    size_t len = ftell(f);
    if(len <= 0)
    {
        fclose(f);
        return false;
    }
    fseek(f, 0, SEEK_SET);

    uint32_t cnt = uint32_t(len >> 9);// div 512
    if(len % 512 != 0)
        cnt += 1;
    if(cnt <= 0)
        cnt = maxcnt - sec;
    else if(cnt > maxcnt - sec)
        cnt = maxcnt - sec;

    if(cnt <= 65536)
        MAXSEC = 128;

    void* buf = malloc(MAXSEC << 9);
    if(!buf)
    {
        fclose(f);
        return false;
    }

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        memset(buf, 0, MAXSEC << 9);
        uint32_t r_n = fread(buf, 1, n*512, f);
        if(r_n != n*512)
        {
            if(r_n != len)
            {
                free(buf);
                fclose(f);
                return false;
            }
        }
        len -= r_n;
        if(!flash_write_lba_raw(sec, n, buf))
        {
            free(buf);
            fclose(f);
            return false;
        }
        sec += n;
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    free(buf);
    fclose(f);
    return true;
}
