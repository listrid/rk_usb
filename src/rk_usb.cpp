#include "rk_common.h"
#include "rk_usb.h"
#include "./libusb/libusb.h"


#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))

static chip_t chips[] =
{
    { 0x0000, "UNKNOWN"},
    { 0x110c, "RK1106" },
    { 0x180a, "RK1808" },
    { 0x281a, "RK2818" },
    { 0x290a, "RK2918" },
    { 0x292a, "RK2928" },
    { 0x292c, "RK3026" },
    { 0x300a, "RK3066" },
    { 0x300b, "RK3168" },
    { 0x301a, "RK3036" },
    { 0x310a, "RK3066" },
    { 0x310b, "RK3188" },
    { 0x310c, "RK3128" },
    { 0x320a, "RK3288" },
    { 0x320b, "RK3228" },
    { 0x320c, "RK3328" },
    { 0x330a, "RK3368" },
    { 0x330c, "RK3399" },
    { 0x330d, "PX30" },
    { 0x330e, "RK3308" },
    { 0x350a, "RK3568" },
    { 0x350b, "RK3588" },
    { 0x350d, "RK3562" },
    { 0x350e, "RK3576" },
    { 0x350f, "RK3506" },
};


static inline void __put_unaligned_le16(uint8_t* p, uint16_t val) { *p++ = uint8_t(val); *p++ = uint8_t(val >> 8); }
static inline void __put_unaligned_be16(uint8_t* p, uint16_t val) { *p++ = uint8_t(val >> 8); *p++ = uint8_t(val); }
static inline void __put_unaligned_le32(uint8_t* p, uint32_t val) { __put_unaligned_le16(p + 2, val >> 16); __put_unaligned_le16(p, val); }
static inline void __put_unaligned_be32(uint8_t* p, uint32_t val) { __put_unaligned_be16(p, val >> 16); __put_unaligned_be16(p + 2, val); }

static inline uint32_t __get_unaligned_be32(const uint8_t* p) { return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | (p[3] << 0); }
static inline uint32_t __get_unaligned_le32(const uint8_t* p) {  return (p[0] << 0) | (p[1] << 8) | (p[2] << 16) | (p[3] << 24); }

static inline void put_unaligned_be16(void* p, uint16_t val) { __put_unaligned_be16((uint8_t*)p, val); }
static inline void put_unaligned_le32(void* p, uint32_t val) { __put_unaligned_le32((uint8_t*)p, val); }
static inline void put_unaligned_be32(void* p, uint32_t val) { __put_unaligned_be32((uint8_t*)p, val); }

static inline uint32_t get_unaligned_be32(const void* p) { return __get_unaligned_be32((const uint8_t*)p); }
static inline uint32_t get_unaligned_le32(const void* p) { return __get_unaligned_le32((const uint8_t*)p); }


RK_usb::RK_usb()
{
    libusb_init(&m_context);
    m_handle  = NULL;
    m_chip = &chips[0];

    m_epout = 0;
    m_epin  = 0;
}


RK_usb::~RK_usb()
{
    if(m_handle)
        libusb_close(m_handle);
    libusb_exit(m_context);
}


bool RK_usb::init()
{
    libusb_device** list = NULL;
    bool found = false;
    if(m_handle)
        return true;
    for(int32_t count = 0; (count < libusb_get_device_list(m_context, &list)) && !found; count++)
    {
        libusb_device_descriptor desc;
        libusb_device* device = list[count];
        libusb_device_handle* hdl;
        if(libusb_get_device_descriptor(device, &desc) == 0)
        {
            if(desc.idVendor == 0x2207)
            {
                for(size_t i = 0; i < ARRAY_SIZE(chips); i++)
                {
                    if(desc.idProduct == chips[i].pid)
                    {
                        if(libusb_open(device, &hdl) == 0)
                        {
                            m_handle = hdl;
                            m_chip = &chips[i];
                            found = true;
                            break;
                        }
                    }
                }
                if(!found)
                {
                    if(libusb_open(device, &hdl) == 0)
                    {
                        m_handle  = hdl;
                        m_chip = &chips[0];
                        found  = true;
                        break;
                    }
                }
            }
        }
    }

    if(m_handle && m_chip && found)
    {
        if(libusb_kernel_driver_active(m_handle, 0))
            libusb_detach_kernel_driver(m_handle, 0);

        if(libusb_claim_interface(m_handle, 0) == 0)
        {
            libusb_device_descriptor desc;
            if(libusb_get_device_descriptor(libusb_get_device(m_handle), &desc) == 0)
            {
                if((desc.bcdUSB & 0x0001) == 0x0000)
                    m_maskrom = true;
                else
                    m_maskrom = false;

                libusb_config_descriptor* config;
                if(libusb_get_active_config_descriptor(libusb_get_device(m_handle), &config) == 0)
                {
                    for(size_t if_idx = 0; if_idx < config->bNumInterfaces; if_idx++)
                    {
                        const libusb_interface* iface = config->interface + if_idx;
                        for(size_t set_idx = 0; set_idx < (size_t)iface->num_altsetting; set_idx++)
                        {
                            const libusb_interface_descriptor* setting = iface->altsetting + set_idx;
                            for(size_t ep_idx = 0; ep_idx < setting->bNumEndpoints; ep_idx++)
                            {
                                const libusb_endpoint_descriptor* ep = setting->endpoint + ep_idx;
                                if((ep->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK) != LIBUSB_TRANSFER_TYPE_BULK)
                                    continue;
                                if((ep->bEndpointAddress & LIBUSB_ENDPOINT_DIR_MASK) == LIBUSB_ENDPOINT_IN)
                                    m_epin = ep->bEndpointAddress;
                                else
                                    m_epout = ep->bEndpointAddress;
                            }
                        }
                    }
                    libusb_free_config_descriptor(config);
                    return true;
                }
            }
        }
    }
    return false;
}

const char* RK_usb::chip_name()
{
    return m_chip->name;
}


bool RK_usb::maskrom_upload_memory(uint32_t code, void* buf, uint64_t len, bool rc4)
{
    uint8_t key[16] = { 124, 78, 3, 4, 85, 5, 9, 7, 45, 44, 123, 56, 23, 13, 23, 17 };
    uint64_t total = 0;
    uint16_t crc16 = 0xffff;
    bool pend = false;
    uint8_t* buffer;

    buffer = (uint8_t*)malloc(len + 5);
    if(buffer)
    {
        memset(buffer, 0, len + 5);
        memcpy(buffer, buf, len);
        if(rc4)
        {
            rc4_ctx rc4;
            rc4.setkey(key, sizeof(key));
            rc4.crypt(buffer, len);
        }
        if((len % 4096) == 4095)
            len++;
        if((len % 4096) == 4094)
            pend = true;
        crc16 = crc16_sum(crc16, buffer, len);
        buffer[len++] = crc16 >> 8;
        buffer[len++] = crc16 & 0xff;
        while(total < len)
        {
            uint16_t n = ((len - total) > 4096) ? 4096 : uint16_t(len - total);
            if(libusb_control_transfer(m_handle, LIBUSB_REQUEST_TYPE_VENDOR, 0xc, 0, code, buffer + total, n, 0) != n)
            {
                free(buffer);
                return false;
            }
            total += n;
        }
        if(pend)
        {
            unsigned char zero = 0;
            libusb_control_transfer(m_handle, LIBUSB_REQUEST_TYPE_VENDOR, 0xc, 0, code, &zero, 1, 0);
        }
        free(buffer);
    }
    return true;
}

bool RK_usb::maskrom_upload_file(uint32_t code, const char* filename, bool rc4)
{
    uint64_t len;
    void* buf;

    buf = file_load(filename, &len);
    if(!buf)
        return false;
    bool ret = maskrom_upload_memory(code, buf, len, rc4);
    free(buf);
    return ret;
}


bool RK_usb::maskrom_dump_arm32(uint32_t uart, uint32_t addr, uint32_t len, bool rc4)
{
    static uint8_t payload[] = {
        0x00, 0x00, 0xa0, 0xe3, 0x17, 0x0f, 0x08, 0xee, 0x15, 0x0f, 0x07, 0xee, 0xd5, 0x0f, 0x07, 0xee,
        0x9a, 0x0f, 0x07, 0xee, 0x95, 0x0f, 0x07, 0xee, 0x08, 0x00, 0x00, 0xea, 0x00, 0x00, 0x4c, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x4f, 0xe2, 0x00, 0xd0, 0x80, 0xe5, 0x04, 0xe0, 0x80, 0xe5, 0x00, 0xe0, 0x0f, 0xe1,
        0x08, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x11, 0xee, 0x0c, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x1c, 0xee,
        0x10, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x11, 0xee, 0x14, 0xe0, 0x80, 0xe5, 0x54, 0x00, 0x1f, 0xe5,
        0x58, 0x10, 0x1f, 0xe5, 0x58, 0x20, 0x1f, 0xe5, 0x1b, 0x00, 0x00, 0xeb, 0x5c, 0x00, 0x4f, 0xe2,
        0x00, 0xd0, 0x90, 0xe5, 0x04, 0xe0, 0x90, 0xe5, 0x14, 0x10, 0x90, 0xe5, 0x10, 0x1f, 0x01, 0xee,
        0x10, 0x10, 0x90, 0xe5, 0x10, 0x1f, 0x0c, 0xee, 0x0c, 0x10, 0x90, 0xe5, 0x10, 0x1f, 0x01, 0xee,
        0x08, 0x10, 0x90, 0xe5, 0x01, 0xf0, 0x29, 0xe1, 0x1e, 0xff, 0x2f, 0xe1, 0x98, 0x10, 0x1f, 0xe5,
        0x7c, 0x20, 0x81, 0xe2, 0x00, 0x20, 0x92, 0xe5, 0x02, 0x20, 0x02, 0xe2, 0x00, 0x00, 0x52, 0xe3,
        0xfa, 0xff, 0xff, 0x0a, 0x00, 0x00, 0x81, 0xe5, 0x1e, 0xff, 0x2f, 0xe1, 0x41, 0x1e, 0x00, 0x00,
        0x00, 0x61, 0x65, 0x61, 0x62, 0x69, 0x00, 0x01, 0x14, 0x00, 0x00, 0x00, 0x05, 0x37, 0x2d, 0x41,
        0x00, 0x06, 0x0a, 0x07, 0x41, 0x08, 0x01, 0x09, 0x02, 0x0a, 0x05, 0x00, 0xf8, 0x4f, 0x2d, 0xe9,
        0x00, 0x70, 0x52, 0xe2, 0xf8, 0x8f, 0xbd, 0xd8, 0x01, 0xa0, 0x47, 0xe2, 0x00, 0x90, 0xa0, 0xe1,
        0x0f, 0xa0, 0xca, 0xe3, 0x01, 0x80, 0xa0, 0xe1, 0x10, 0x60, 0xa0, 0xe3, 0x20, 0xa0, 0x8a, 0xe2,
        0x16, 0x02, 0x79, 0xe3, 0x10, 0x50, 0x46, 0xe2, 0x29, 0x0e, 0xa0, 0xe1, 0x05, 0xb0, 0xa0, 0xe1,
        0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xdf, 0xff, 0xff, 0xeb, 0x59, 0x0c, 0xe3, 0xe7,
        0x09, 0x00, 0x50, 0xe3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xda, 0xff, 0xff, 0xeb,
        0x59, 0x0a, 0xe3, 0xe7, 0x09, 0x00, 0x50, 0xe3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82,
        0xd5, 0xff, 0xff, 0xeb, 0x59, 0x08, 0xe3, 0xe7, 0x09, 0x00, 0x50, 0xe3, 0x30, 0x00, 0x80, 0x92,
        0x57, 0x00, 0x80, 0x82, 0xd0, 0xff, 0xff, 0xeb, 0x59, 0x06, 0xe3, 0xe7, 0x09, 0x00, 0x50, 0xe3,
        0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xcb, 0xff, 0xff, 0xeb, 0x59, 0x04, 0xe3, 0xe7,
        0x09, 0x00, 0x50, 0xe3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82, 0xc6, 0xff, 0xff, 0xeb,
        0x59, 0x02, 0xe3, 0xe7, 0x09, 0x00, 0x50, 0xe3, 0x30, 0x00, 0x80, 0x92, 0x57, 0x00, 0x80, 0x82,
        0xc1, 0xff, 0xff, 0xeb, 0x0f, 0x00, 0x09, 0xe2, 0x09, 0x00, 0x50, 0xe3, 0x30, 0x00, 0x80, 0x92,
        0x57, 0x00, 0x80, 0x82, 0xbc, 0xff, 0xff, 0xeb, 0x3a, 0x00, 0xa0, 0xe3, 0xba, 0xff, 0xff, 0xeb,
        0x20, 0x00, 0xa0, 0xe3, 0xb8, 0xff, 0xff, 0xeb, 0x0f, 0x00, 0x00, 0xea, 0x0b, 0x40, 0xd8, 0xe7,
        0x24, 0x32, 0xa0, 0xe1, 0x9f, 0x00, 0x54, 0xe3, 0x57, 0x00, 0x83, 0xe2, 0x0f, 0x40, 0x04, 0xe2,
        0x30, 0x00, 0x83, 0x92, 0xb0, 0xff, 0xff, 0xeb, 0x09, 0x00, 0x54, 0xe3, 0x57, 0x00, 0x84, 0xe2,
        0x30, 0x00, 0x84, 0x92, 0x01, 0xb0, 0x8b, 0xe2, 0xab, 0xff, 0xff, 0xeb, 0x20, 0x00, 0xa0, 0xe3,
        0xa9, 0xff, 0xff, 0xeb, 0x0b, 0x00, 0x56, 0xe1, 0x05, 0x00, 0x00, 0x0a, 0x0b, 0x00, 0x57, 0xe1,
        0xed, 0xff, 0xff, 0xca, 0x20, 0x00, 0xa0, 0xe3, 0xa3, 0xff, 0xff, 0xeb, 0x20, 0x00, 0xa0, 0xe3,
        0xf3, 0xff, 0xff, 0xea, 0x7c, 0x00, 0xa0, 0xe3, 0x9f, 0xff, 0xff, 0xeb, 0x08, 0x00, 0x00, 0xea,
        0x05, 0x30, 0xd8, 0xe7, 0x2e, 0x00, 0xa0, 0xe3, 0x01, 0x50, 0x85, 0xe2, 0x20, 0x20, 0x43, 0xe2,
        0x5e, 0x00, 0x52, 0xe3, 0x03, 0x00, 0xa0, 0x91, 0x97, 0xff, 0xff, 0xeb, 0x05, 0x00, 0x56, 0xe1,
        0x06, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x57, 0xe1, 0xf4, 0xff, 0xff, 0xca, 0x20, 0x00, 0xa0, 0xe3,
        0x01, 0x50, 0x85, 0xe2, 0x90, 0xff, 0xff, 0xeb, 0x05, 0x00, 0x56, 0xe1, 0xf8, 0xff, 0xff, 0x1a,
        0x0d, 0x00, 0xa0, 0xe3, 0x10, 0x60, 0x86, 0xe2, 0x10, 0x90, 0x89, 0xe2, 0x8a, 0xff, 0xff, 0xeb,
        0x0a, 0x00, 0xa0, 0xe3, 0x88, 0xff, 0xff, 0xeb, 0x06, 0x00, 0x5a, 0xe1, 0x9f, 0xff, 0xff, 0x1a,
        0xf8, 0x8f, 0xbd, 0xe8, 0x47, 0x43, 0x43, 0x3a, 0x20, 0x28, 0x31, 0x35, 0x3a, 0x39, 0x2d, 0x32,
        0x30, 0x31, 0x39, 0x2d, 0x71, 0x34, 0x2d, 0x30, 0x75, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x31, 0x29,
        0x20, 0x39, 0x2e, 0x32, 0x2e, 0x31, 0x20, 0x32, 0x30, 0x31, 0x39, 0x31, 0x30, 0x32, 0x35, 0x20,
        0x28, 0x72, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x29, 0x20, 0x5b, 0x41, 0x52, 0x4d, 0x2f, 0x61,
        0x72, 0x6d, 0x2d, 0x39, 0x2d, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x20, 0x72, 0x65, 0x76, 0x69,
        0x73, 0x69, 0x6f, 0x6e, 0x20, 0x32, 0x37, 0x37, 0x35, 0x39, 0x39, 0x5d, 0x00, 0x41, 0x2e, 0x00,
        0x00, 0x00, 0x61, 0x65, 0x61, 0x62, 0x69, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x05, 0x37, 0x2d,
        0x41, 0x00, 0x06, 0x0a, 0x07, 0x41, 0x08, 0x01, 0x09, 0x02, 0x0a, 0x05, 0x12, 0x04, 0x14, 0x01,
        0x15, 0x01, 0x17, 0x03, 0x18, 0x01, 0x19, 0x01, 0x1a, 0x01, 0x1e, 0x02
    };

    put_unaligned_le32(&payload[0x1c], uart);
    put_unaligned_le32(&payload[0x20], addr);
    put_unaligned_le32(&payload[0x24], len);
    return maskrom_upload_memory(0x471, payload, sizeof(payload), rc4);
}

bool RK_usb::maskrom_dump_arm64(uint32_t uart, uint32_t addr, uint32_t len, bool rc4)
{
    static uint8_t payload[] = {
        0xdf, 0x3f, 0x03, 0xd5, 0x9f, 0x3f, 0x03, 0xd5, 0x0c, 0x00, 0x00, 0x14, 0x00, 0x00, 0xd4, 0x2a,
        0x00, 0x00, 0xff, 0xff, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x10, 0xe1, 0x03, 0x1e, 0xaa,
        0x01, 0x00, 0x00, 0xb9, 0xe1, 0x03, 0x1d, 0xaa, 0x01, 0x04, 0x00, 0xb9, 0xe1, 0x03, 0x1c, 0xaa,
        0x01, 0x08, 0x00, 0xb9, 0xe1, 0x03, 0x00, 0x91, 0x01, 0x0c, 0x00, 0xb9, 0xa0, 0xfd, 0xff, 0x18,
        0x81, 0xfd, 0xff, 0x18, 0x82, 0xfd, 0xff, 0x18, 0x16, 0x00, 0x00, 0x94, 0xe1, 0x03, 0x1f, 0xaa,
        0x40, 0xfd, 0xff, 0x10, 0x01, 0x00, 0x40, 0xb9, 0xfe, 0x03, 0x01, 0xaa, 0x01, 0x04, 0x40, 0xb9,
        0xfd, 0x03, 0x01, 0xaa, 0x01, 0x08, 0x40, 0xb9, 0xfc, 0x03, 0x01, 0xaa, 0x01, 0x0c, 0x40, 0xb9,
        0x3f, 0x00, 0x00, 0x91, 0x00, 0x00, 0x80, 0xd2, 0xc0, 0x03, 0x5f, 0xd6, 0x81, 0xfb, 0xff, 0x18,
        0x22, 0xf0, 0x01, 0x91, 0x42, 0x00, 0x40, 0xb9, 0x42, 0x00, 0x1f, 0x12, 0x5f, 0x00, 0x00, 0x71,
        0x80, 0xff, 0xff, 0x54, 0x20, 0x00, 0x00, 0xf9, 0xc0, 0x03, 0x5f, 0xd6, 0x00, 0x00, 0x00, 0x00,
        0x5f, 0x00, 0x00, 0x71, 0xed, 0x11, 0x00, 0x54, 0xfd, 0x7b, 0xba, 0xa9, 0xfd, 0x03, 0x00, 0x91,
        0xf9, 0x6b, 0x04, 0xa9, 0x5a, 0x04, 0x00, 0x51, 0x5a, 0x6f, 0x1c, 0x12, 0x5a, 0x43, 0x00, 0x11,
        0xf3, 0x53, 0x01, 0xa9, 0x34, 0x40, 0x00, 0x91, 0xf5, 0x5b, 0x02, 0xa9, 0xf6, 0x03, 0x02, 0x2a,
        0x19, 0x00, 0x80, 0x52, 0xf7, 0x63, 0x03, 0xa9, 0xf7, 0x03, 0x00, 0xaa, 0xf8, 0x03, 0x01, 0xaa,
        0xfb, 0x2b, 0x00, 0xf9, 0x1f, 0x20, 0x03, 0xd5, 0xe1, 0x7e, 0x1c, 0x53, 0xfb, 0x03, 0x18, 0xaa,
        0x3f, 0x24, 0x00, 0x71, 0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11, 0x35, 0x03, 0x18, 0x4b,
        0x20, 0x80, 0x80, 0x1a, 0xde, 0xff, 0xff, 0x97, 0xe1, 0x6e, 0x18, 0x53, 0x3f, 0x24, 0x00, 0x71,
        0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1a, 0xd8, 0xff, 0xff, 0x97,
        0xe1, 0x5e, 0x14, 0x53, 0x3f, 0x24, 0x00, 0x71, 0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11,
        0x20, 0x80, 0x80, 0x1a, 0xd2, 0xff, 0xff, 0x97, 0xe1, 0x4e, 0x10, 0x53, 0x3f, 0x24, 0x00, 0x71,
        0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1a, 0xcc, 0xff, 0xff, 0x97,
        0xe1, 0x3e, 0x0c, 0x53, 0x3f, 0x24, 0x00, 0x71, 0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11,
        0x20, 0x80, 0x80, 0x1a, 0xc6, 0xff, 0xff, 0x97, 0xe1, 0x2e, 0x08, 0x53, 0x3f, 0x24, 0x00, 0x71,
        0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1a, 0xc0, 0xff, 0xff, 0x97,
        0xe1, 0x1e, 0x04, 0x53, 0x3f, 0x24, 0x00, 0x71, 0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11,
        0x20, 0x80, 0x80, 0x1a, 0xba, 0xff, 0xff, 0x97, 0xe1, 0x0e, 0x00, 0x12, 0x3f, 0x24, 0x00, 0x71,
        0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1a, 0xb4, 0xff, 0xff, 0x97,
        0x40, 0x07, 0x80, 0x52, 0xb2, 0xff, 0xff, 0x97, 0x00, 0x04, 0x80, 0x52, 0xb0, 0xff, 0xff, 0x97,
        0x13, 0x00, 0x00, 0x14, 0x73, 0x03, 0x40, 0x39, 0x7b, 0x07, 0x00, 0x91, 0x61, 0x7e, 0x04, 0x53,
        0x3f, 0x24, 0x00, 0x71, 0x20, 0xc0, 0x00, 0x11, 0x21, 0x5c, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1a,
        0xa7, 0xff, 0xff, 0x97, 0x61, 0x0e, 0x00, 0x12, 0x3f, 0x24, 0x00, 0x71, 0x20, 0xc0, 0x00, 0x11,
        0x21, 0x5c, 0x01, 0x11, 0x20, 0x80, 0x80, 0x1a, 0xa1, 0xff, 0xff, 0x97, 0x00, 0x04, 0x80, 0x52,
        0x9f, 0xff, 0xff, 0x97, 0x9f, 0x02, 0x1b, 0xeb, 0xa0, 0x01, 0x00, 0x54, 0xa0, 0x02, 0x1b, 0x0b,
        0x1f, 0x00, 0x16, 0x6b, 0x8b, 0xfd, 0xff, 0x54, 0x00, 0x04, 0x80, 0x52, 0x98, 0xff, 0xff, 0x97,
        0x00, 0x04, 0x80, 0x52, 0x96, 0xff, 0xff, 0x97, 0x7b, 0x07, 0x00, 0x91, 0x00, 0x04, 0x80, 0x52,
        0x93, 0xff, 0xff, 0x97, 0x9f, 0x02, 0x1b, 0xeb, 0xa1, 0xfe, 0xff, 0x54, 0xf3, 0x03, 0x18, 0xaa,
        0x80, 0x0f, 0x80, 0x52, 0x8e, 0xff, 0xff, 0x97, 0x06, 0x00, 0x00, 0x14, 0xe0, 0x03, 0x01, 0x2a,
        0x8b, 0xff, 0xff, 0x97, 0x73, 0x06, 0x00, 0x91, 0x9f, 0x02, 0x13, 0xeb, 0xa0, 0x01, 0x00, 0x54,
        0xa0, 0x02, 0x13, 0x0b, 0xdf, 0x02, 0x00, 0x6b, 0x6d, 0x03, 0x00, 0x54, 0x61, 0x02, 0x40, 0x39,
        0xc0, 0x05, 0x80, 0x52, 0x22, 0x80, 0x00, 0x51, 0x5f, 0x78, 0x01, 0x71, 0x89, 0xfe, 0xff, 0x54,
        0x73, 0x06, 0x00, 0x91, 0x7e, 0xff, 0xff, 0x97, 0x9f, 0x02, 0x13, 0xeb, 0xa1, 0xfe, 0xff, 0x54,
        0xa0, 0x01, 0x80, 0x52, 0x7a, 0xff, 0xff, 0x97, 0x39, 0x43, 0x00, 0x11, 0x40, 0x01, 0x80, 0x52,
        0x77, 0xff, 0xff, 0x97, 0xf7, 0x42, 0x00, 0x91, 0x94, 0x42, 0x00, 0x91, 0x18, 0x43, 0x00, 0x91,
        0x3f, 0x03, 0x1a, 0x6b, 0xa1, 0xf1, 0xff, 0x54, 0xf3, 0x53, 0x41, 0xa9, 0xf5, 0x5b, 0x42, 0xa9,
        0xf7, 0x63, 0x43, 0xa9, 0xf9, 0x6b, 0x44, 0xa9, 0xfb, 0x2b, 0x40, 0xf9, 0xfd, 0x7b, 0xc6, 0xa8,
        0xc0, 0x03, 0x5f, 0xd6, 0x00, 0x04, 0x80, 0x52, 0x69, 0xff, 0xff, 0x97, 0xde, 0xff, 0xff, 0x17,
        0xc0, 0x03, 0x5f, 0xd6, 0x04, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x47, 0x4e, 0x55, 0x00, 0x59, 0xc7, 0xed, 0x47, 0xc6, 0xfd, 0xa5, 0xcd, 0x23, 0xf7, 0x31, 0x5a,
        0x12, 0x98, 0x30, 0xfd, 0xfe, 0x28, 0xdf, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    put_unaligned_le32(&payload[0x0c], uart);
    put_unaligned_le32(&payload[0x10], addr);
    put_unaligned_le32(&payload[0x14], len);
    return maskrom_upload_memory(0x471, payload, sizeof(payload), rc4);
}

bool RK_usb::maskrom_write_arm32(uint32_t addr, void* buf, size_t len, bool rc4)
{
    static const uint8_t payload[] =
    {
        0x00, 0x00, 0xa0, 0xe3, 0x17, 0x0f, 0x08, 0xee, 0x15, 0x0f, 0x07, 0xee, 0xd5, 0x0f, 0x07, 0xee,
        0x9a, 0x0f, 0x07, 0xee, 0x95, 0x0f, 0x07, 0xee, 0x28, 0x01, 0x00, 0xea, 0x00, 0x00, 0x51, 0xe1,
        0x91, 0x00, 0x00, 0x3a, 0x00, 0x00, 0xa0, 0x03, 0x0e, 0xf0, 0xa0, 0x01, 0x01, 0x40, 0x2d, 0xe9,
        0x04, 0x20, 0x52, 0xe2, 0x20, 0x00, 0x00, 0xba, 0x03, 0xc0, 0x10, 0xe2, 0x28, 0x00, 0x00, 0x1a,
        0x03, 0xc0, 0x11, 0xe2, 0x32, 0x00, 0x00, 0x1a, 0x08, 0x20, 0x52, 0xe2, 0x12, 0x00, 0x00, 0xba,
        0x14, 0x20, 0x52, 0xe2, 0x0b, 0x00, 0x00, 0xba, 0x10, 0x00, 0x2d, 0xe9, 0x18, 0x50, 0xb1, 0xe8,
        0x18, 0x50, 0xa0, 0xe8, 0x18, 0x50, 0xb1, 0xe8, 0x18, 0x50, 0xa0, 0xe8, 0x20, 0x20, 0x52, 0xe2,
        0xf9, 0xff, 0xff, 0xaa, 0x10, 0x00, 0x72, 0xe3, 0x18, 0x50, 0xb1, 0xa8, 0x18, 0x50, 0xa0, 0xa8,
        0x10, 0x20, 0x42, 0xa2, 0x10, 0x00, 0xbd, 0xe8, 0x14, 0x20, 0x92, 0xe2, 0x08, 0x50, 0xb1, 0xa8,
        0x08, 0x50, 0xa0, 0xa8, 0x0c, 0x20, 0x52, 0xa2, 0xfb, 0xff, 0xff, 0xaa, 0x08, 0x20, 0x92, 0xe2,
        0x05, 0x00, 0x00, 0xba, 0x04, 0x20, 0x52, 0xe2, 0x04, 0x30, 0x91, 0xb4, 0x04, 0x30, 0x80, 0xb4,
        0x08, 0x10, 0xb1, 0xa8, 0x08, 0x10, 0xa0, 0xa8, 0x04, 0x20, 0x42, 0xa2, 0x04, 0x20, 0x92, 0xe2,
        0x01, 0x80, 0xbd, 0x08, 0x02, 0x00, 0x52, 0xe3, 0x01, 0x30, 0xd1, 0xe4, 0x01, 0x30, 0xc0, 0xe4,
        0x01, 0x30, 0xd1, 0xa4, 0x01, 0x30, 0xc0, 0xa4, 0x01, 0x30, 0xd1, 0xc4, 0x01, 0x30, 0xc0, 0xc4,
        0x01, 0x80, 0xbd, 0xe8, 0x04, 0xc0, 0x6c, 0xe2, 0x02, 0x00, 0x5c, 0xe3, 0x01, 0x30, 0xd1, 0xe4,
        0x01, 0x30, 0xc0, 0xe4, 0x01, 0x30, 0xd1, 0xa4, 0x01, 0x30, 0xc0, 0xa4, 0x01, 0x30, 0xd1, 0xc4,
        0x01, 0x30, 0xc0, 0xc4, 0x0c, 0x20, 0x52, 0xe0, 0xeb, 0xff, 0xff, 0xba, 0x03, 0xc0, 0x11, 0xe2,
        0xcc, 0xff, 0xff, 0x0a, 0x03, 0x10, 0xc1, 0xe3, 0x04, 0xe0, 0x91, 0xe4, 0x02, 0x00, 0x5c, 0xe3,
        0x36, 0x00, 0x00, 0xca, 0x1a, 0x00, 0x00, 0x0a, 0x0c, 0x00, 0x52, 0xe3, 0x10, 0x00, 0x00, 0xba,
        0x0c, 0x20, 0x42, 0xe2, 0x30, 0x00, 0x2d, 0xe9, 0x2e, 0x34, 0xa0, 0xe1, 0x30, 0x50, 0xb1, 0xe8,
        0x04, 0x3c, 0x83, 0xe1, 0x24, 0x44, 0xa0, 0xe1, 0x05, 0x4c, 0x84, 0xe1, 0x25, 0x54, 0xa0, 0xe1,
        0x0c, 0x5c, 0x85, 0xe1, 0x2c, 0xc4, 0xa0, 0xe1, 0x0e, 0xcc, 0x8c, 0xe1, 0x38, 0x10, 0xa0, 0xe8,
        0x10, 0x20, 0x52, 0xe2, 0xf3, 0xff, 0xff, 0xaa, 0x30, 0x00, 0xbd, 0xe8, 0x0c, 0x20, 0x92, 0xe2,
        0x05, 0x00, 0x00, 0xba, 0x2e, 0xc4, 0xa0, 0xe1, 0x04, 0xe0, 0x91, 0xe4, 0x0e, 0xcc, 0x8c, 0xe1,
        0x04, 0xc0, 0x80, 0xe4, 0x04, 0x20, 0x52, 0xe2, 0xf9, 0xff, 0xff, 0xaa, 0x03, 0x10, 0x41, 0xe2,
        0xc9, 0xff, 0xff, 0xea, 0x0c, 0x00, 0x52, 0xe3, 0x10, 0x00, 0x00, 0xba, 0x0c, 0x20, 0x42, 0xe2,
        0x30, 0x00, 0x2d, 0xe9, 0x2e, 0x38, 0xa0, 0xe1, 0x30, 0x50, 0xb1, 0xe8, 0x04, 0x38, 0x83, 0xe1,
        0x24, 0x48, 0xa0, 0xe1, 0x05, 0x48, 0x84, 0xe1, 0x25, 0x58, 0xa0, 0xe1, 0x0c, 0x58, 0x85, 0xe1,
        0x2c, 0xc8, 0xa0, 0xe1, 0x0e, 0xc8, 0x8c, 0xe1, 0x38, 0x10, 0xa0, 0xe8, 0x10, 0x20, 0x52, 0xe2,
        0xf3, 0xff, 0xff, 0xaa, 0x30, 0x00, 0xbd, 0xe8, 0x0c, 0x20, 0x92, 0xe2, 0x05, 0x00, 0x00, 0xba,
        0x2e, 0xc8, 0xa0, 0xe1, 0x04, 0xe0, 0x91, 0xe4, 0x0e, 0xc8, 0x8c, 0xe1, 0x04, 0xc0, 0x80, 0xe4,
        0x04, 0x20, 0x52, 0xe2, 0xf9, 0xff, 0xff, 0xaa, 0x02, 0x10, 0x41, 0xe2, 0xae, 0xff, 0xff, 0xea,
        0x0c, 0x00, 0x52, 0xe3, 0x10, 0x00, 0x00, 0xba, 0x0c, 0x20, 0x42, 0xe2, 0x30, 0x00, 0x2d, 0xe9,
        0x2e, 0x3c, 0xa0, 0xe1, 0x30, 0x50, 0xb1, 0xe8, 0x04, 0x34, 0x83, 0xe1, 0x24, 0x4c, 0xa0, 0xe1,
        0x05, 0x44, 0x84, 0xe1, 0x25, 0x5c, 0xa0, 0xe1, 0x0c, 0x54, 0x85, 0xe1, 0x2c, 0xcc, 0xa0, 0xe1,
        0x0e, 0xc4, 0x8c, 0xe1, 0x38, 0x10, 0xa0, 0xe8, 0x10, 0x20, 0x52, 0xe2, 0xf3, 0xff, 0xff, 0xaa,
        0x30, 0x00, 0xbd, 0xe8, 0x0c, 0x20, 0x92, 0xe2, 0x05, 0x00, 0x00, 0xba, 0x2e, 0xcc, 0xa0, 0xe1,
        0x04, 0xe0, 0x91, 0xe4, 0x0e, 0xc4, 0x8c, 0xe1, 0x04, 0xc0, 0x80, 0xe4, 0x04, 0x20, 0x52, 0xe2,
        0xf9, 0xff, 0xff, 0xaa, 0x01, 0x10, 0x41, 0xe2, 0x93, 0xff, 0xff, 0xea, 0x02, 0x10, 0x81, 0xe0,
        0x02, 0x00, 0x80, 0xe0, 0x04, 0x20, 0x52, 0xe2, 0x1f, 0x00, 0x00, 0xba, 0x03, 0xc0, 0x10, 0xe2,
        0x27, 0x00, 0x00, 0x1a, 0x03, 0xc0, 0x11, 0xe2, 0x30, 0x00, 0x00, 0x1a, 0x08, 0x20, 0x52, 0xe2,
        0x11, 0x00, 0x00, 0xba, 0x10, 0x40, 0x2d, 0xe9, 0x14, 0x20, 0x52, 0xe2, 0x05, 0x00, 0x00, 0xba,
        0x18, 0x50, 0x31, 0xe9, 0x18, 0x50, 0x20, 0xe9, 0x18, 0x50, 0x31, 0xe9, 0x18, 0x50, 0x20, 0xe9,
        0x20, 0x20, 0x52, 0xe2, 0xf9, 0xff, 0xff, 0xaa, 0x10, 0x00, 0x72, 0xe3, 0x18, 0x50, 0x31, 0xa9,
        0x18, 0x50, 0x20, 0xa9, 0x10, 0x20, 0x42, 0xa2, 0x14, 0x20, 0x92, 0xe2, 0x08, 0x50, 0x31, 0xa9,
        0x08, 0x50, 0x20, 0xa9, 0x0c, 0x20, 0x42, 0xa2, 0x10, 0x40, 0xbd, 0xe8, 0x08, 0x20, 0x92, 0xe2,
        0x05, 0x00, 0x00, 0xba, 0x04, 0x20, 0x52, 0xe2, 0x04, 0x30, 0x31, 0xb5, 0x04, 0x30, 0x20, 0xb5,
        0x08, 0x10, 0x31, 0xa9, 0x08, 0x10, 0x20, 0xa9, 0x04, 0x20, 0x42, 0xa2, 0x04, 0x20, 0x92, 0xe2,
        0x0e, 0xf0, 0xa0, 0x01, 0x02, 0x00, 0x52, 0xe3, 0x01, 0x30, 0x71, 0xe5, 0x01, 0x30, 0x60, 0xe5,
        0x01, 0x30, 0x71, 0xa5, 0x01, 0x30, 0x60, 0xa5, 0x01, 0x30, 0x71, 0xc5, 0x01, 0x30, 0x60, 0xc5,
        0x0e, 0xf0, 0xa0, 0xe1, 0x02, 0x00, 0x5c, 0xe3, 0x01, 0x30, 0x71, 0xe5, 0x01, 0x30, 0x60, 0xe5,
        0x01, 0x30, 0x71, 0xa5, 0x01, 0x30, 0x60, 0xa5, 0x01, 0x30, 0x71, 0xc5, 0x01, 0x30, 0x60, 0xc5,
        0x0c, 0x20, 0x52, 0xe0, 0xec, 0xff, 0xff, 0xba, 0x03, 0xc0, 0x11, 0xe2, 0xce, 0xff, 0xff, 0x0a,
        0x03, 0x10, 0xc1, 0xe3, 0x00, 0x30, 0x91, 0xe5, 0x02, 0x00, 0x5c, 0xe3, 0x36, 0x00, 0x00, 0xba,
        0x1a, 0x00, 0x00, 0x0a, 0x0c, 0x00, 0x52, 0xe3, 0x10, 0x00, 0x00, 0xba, 0x0c, 0x20, 0x42, 0xe2,
        0x30, 0x40, 0x2d, 0xe9, 0x03, 0xe4, 0xa0, 0xe1, 0x38, 0x10, 0x31, 0xe9, 0x2c, 0xec, 0x8e, 0xe1,
        0x0c, 0xc4, 0xa0, 0xe1, 0x25, 0xcc, 0x8c, 0xe1, 0x05, 0x54, 0xa0, 0xe1, 0x24, 0x5c, 0x85, 0xe1,
        0x04, 0x44, 0xa0, 0xe1, 0x23, 0x4c, 0x84, 0xe1, 0x30, 0x50, 0x20, 0xe9, 0x10, 0x20, 0x52, 0xe2,
        0xf3, 0xff, 0xff, 0xaa, 0x30, 0x40, 0xbd, 0xe8, 0x0c, 0x20, 0x92, 0xe2, 0x05, 0x00, 0x00, 0xba,
        0x03, 0xc4, 0xa0, 0xe1, 0x04, 0x30, 0x31, 0xe5, 0x23, 0xcc, 0x8c, 0xe1, 0x04, 0xc0, 0x20, 0xe5,
        0x04, 0x20, 0x52, 0xe2, 0xf9, 0xff, 0xff, 0xaa, 0x03, 0x10, 0x81, 0xe2, 0xca, 0xff, 0xff, 0xea,
        0x0c, 0x00, 0x52, 0xe3, 0x10, 0x00, 0x00, 0xba, 0x0c, 0x20, 0x42, 0xe2, 0x30, 0x40, 0x2d, 0xe9,
        0x03, 0xe8, 0xa0, 0xe1, 0x38, 0x10, 0x31, 0xe9, 0x2c, 0xe8, 0x8e, 0xe1, 0x0c, 0xc8, 0xa0, 0xe1,
        0x25, 0xc8, 0x8c, 0xe1, 0x05, 0x58, 0xa0, 0xe1, 0x24, 0x58, 0x85, 0xe1, 0x04, 0x48, 0xa0, 0xe1,
        0x23, 0x48, 0x84, 0xe1, 0x30, 0x50, 0x20, 0xe9, 0x10, 0x20, 0x52, 0xe2, 0xf3, 0xff, 0xff, 0xaa,
        0x30, 0x40, 0xbd, 0xe8, 0x0c, 0x20, 0x92, 0xe2, 0x05, 0x00, 0x00, 0xba, 0x03, 0xc8, 0xa0, 0xe1,
        0x04, 0x30, 0x31, 0xe5, 0x23, 0xc8, 0x8c, 0xe1, 0x04, 0xc0, 0x20, 0xe5, 0x04, 0x20, 0x52, 0xe2,
        0xf9, 0xff, 0xff, 0xaa, 0x02, 0x10, 0x81, 0xe2, 0xaf, 0xff, 0xff, 0xea, 0x0c, 0x00, 0x52, 0xe3,
        0x10, 0x00, 0x00, 0xba, 0x0c, 0x20, 0x42, 0xe2, 0x30, 0x40, 0x2d, 0xe9, 0x03, 0xec, 0xa0, 0xe1,
        0x38, 0x10, 0x31, 0xe9, 0x2c, 0xe4, 0x8e, 0xe1, 0x0c, 0xcc, 0xa0, 0xe1, 0x25, 0xc4, 0x8c, 0xe1,
        0x05, 0x5c, 0xa0, 0xe1, 0x24, 0x54, 0x85, 0xe1, 0x04, 0x4c, 0xa0, 0xe1, 0x23, 0x44, 0x84, 0xe1,
        0x30, 0x50, 0x20, 0xe9, 0x10, 0x20, 0x52, 0xe2, 0xf3, 0xff, 0xff, 0xaa, 0x30, 0x40, 0xbd, 0xe8,
        0x0c, 0x20, 0x92, 0xe2, 0x05, 0x00, 0x00, 0xba, 0x03, 0xcc, 0xa0, 0xe1, 0x04, 0x30, 0x31, 0xe5,
        0x23, 0xc4, 0x8c, 0xe1, 0x04, 0xc0, 0x20, 0xe5, 0x04, 0x20, 0x52, 0xe2, 0xf9, 0xff, 0xff, 0xaa,
        0x01, 0x10, 0x81, 0xe2, 0x94, 0xff, 0xff, 0xea, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x4f, 0xe2, 0x00, 0xd0, 0x80, 0xe5, 0x04, 0xe0, 0x80, 0xe5, 0x00, 0xe0, 0x0f, 0xe1,
        0x08, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x11, 0xee, 0x0c, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x1c, 0xee,
        0x10, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x11, 0xee, 0x14, 0xe0, 0x80, 0xe5, 0x54, 0x00, 0x8f, 0xe2,
        0x48, 0x10, 0x9f, 0xe5, 0x01, 0x00, 0x50, 0xe1, 0x03, 0x00, 0x00, 0x0a, 0x3c, 0x00, 0x9f, 0xe5,
        0x40, 0x10, 0x8f, 0xe2, 0x38, 0x20, 0x9f, 0xe5, 0xc3, 0xfe, 0xff, 0xeb, 0x00, 0x00, 0xa0, 0xe1,
        0x70, 0x00, 0x4f, 0xe2, 0x00, 0xd0, 0x90, 0xe5, 0x04, 0xe0, 0x90, 0xe5, 0x14, 0x10, 0x90, 0xe5,
        0x10, 0x1f, 0x01, 0xee, 0x10, 0x10, 0x90, 0xe5, 0x10, 0x1f, 0x0c, 0xee, 0x0c, 0x10, 0x90, 0xe5,
        0x10, 0x1f, 0x01, 0xee, 0x08, 0x10, 0x90, 0xe5, 0x01, 0xf0, 0x29, 0xe1, 0x1e, 0xff, 0x2f, 0xe1
    };

    uint8_t* tmp = (uint8_t*)malloc(sizeof(payload) + 8 + len);
    memcpy(&tmp[0], &payload[0], sizeof(payload));
    put_unaligned_le32(tmp + sizeof(payload) + 0, addr);
    put_unaligned_le32(tmp + sizeof(payload) + 4, (uint32_t)len);
    memcpy(tmp + sizeof(payload) + 8, buf, len);
    bool ret = maskrom_upload_memory(0x471, tmp, sizeof(payload) + 8 + len, rc4);
    free(tmp);
    return ret;
}

bool RK_usb::maskrom_write_arm64(uint32_t addr, void* buf, size_t len, bool rc4)
{
    static const uint8_t payload[] = {
        0xdf, 0x3f, 0x03, 0xd5, 0x9f, 0x3f, 0x03, 0xd5, 0x44, 0x00, 0x00, 0x14, 0xff, 0xc3, 0x00, 0xd1,
        0xe0, 0x0f, 0x00, 0xf9, 0xe1, 0x0b, 0x00, 0xf9, 0xe2, 0x07, 0x00, 0xf9, 0xe1, 0x0f, 0x40, 0xf9,
        0xe0, 0x0b, 0x40, 0xf9, 0x3f, 0x00, 0x00, 0xeb, 0x88, 0x02, 0x00, 0x54, 0xe0, 0x0f, 0x40, 0xf9,
        0xe0, 0x13, 0x00, 0xf9, 0xe0, 0x0b, 0x40, 0xf9, 0xe0, 0x17, 0x00, 0xf9, 0x09, 0x00, 0x00, 0x14,
        0xe1, 0x17, 0x40, 0xf9, 0x20, 0x04, 0x00, 0x91, 0xe0, 0x17, 0x00, 0xf9, 0xe0, 0x13, 0x40, 0xf9,
        0x02, 0x04, 0x00, 0x91, 0xe2, 0x13, 0x00, 0xf9, 0x21, 0x00, 0x40, 0x39, 0x01, 0x00, 0x00, 0x39,
        0xe0, 0x07, 0x40, 0xf9, 0x01, 0x04, 0x00, 0xd1, 0xe1, 0x07, 0x00, 0xf9, 0x1f, 0x00, 0x00, 0xf1,
        0x81, 0xfe, 0xff, 0x54, 0x1d, 0x00, 0x00, 0x14, 0xe0, 0x0f, 0x40, 0xf9, 0xe0, 0x13, 0x00, 0xf9,
        0xe1, 0x13, 0x40, 0xf9, 0xe0, 0x07, 0x40, 0xf9, 0x20, 0x00, 0x00, 0x8b, 0xe0, 0x13, 0x00, 0xf9,
        0xe0, 0x0b, 0x40, 0xf9, 0xe0, 0x17, 0x00, 0xf9, 0xe1, 0x17, 0x40, 0xf9, 0xe0, 0x07, 0x40, 0xf9,
        0x20, 0x00, 0x00, 0x8b, 0xe0, 0x17, 0x00, 0xf9, 0x0b, 0x00, 0x00, 0x14, 0xe0, 0x17, 0x40, 0xf9,
        0x00, 0x04, 0x00, 0xd1, 0xe0, 0x17, 0x00, 0xf9, 0xe0, 0x13, 0x40, 0xf9, 0x00, 0x04, 0x00, 0xd1,
        0xe0, 0x13, 0x00, 0xf9, 0xe0, 0x17, 0x40, 0xf9, 0x01, 0x00, 0x40, 0x39, 0xe0, 0x13, 0x40, 0xf9,
        0x01, 0x00, 0x00, 0x39, 0xe0, 0x07, 0x40, 0xf9, 0x01, 0x04, 0x00, 0xd1, 0xe1, 0x07, 0x00, 0xf9,
        0x1f, 0x00, 0x00, 0xf1, 0x41, 0xfe, 0xff, 0x54, 0xe0, 0x0f, 0x40, 0xf9, 0xff, 0xc3, 0x00, 0x91,
        0xc0, 0x03, 0x5f, 0xd6, 0x1f, 0x20, 0x03, 0xd5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x10, 0xe1, 0x03, 0x1e, 0xaa,
        0x01, 0x00, 0x00, 0xb9, 0xe1, 0x03, 0x1d, 0xaa, 0x01, 0x04, 0x00, 0xb9, 0xe1, 0x03, 0x1c, 0xaa,
        0x01, 0x08, 0x00, 0xb9, 0xe1, 0x03, 0x00, 0x91, 0x01, 0x0c, 0x00, 0xb9, 0xe0, 0x02, 0x00, 0x10,
        0x81, 0x02, 0x00, 0x18, 0x1f, 0x00, 0x01, 0xeb, 0xa0, 0x00, 0x00, 0x54, 0x20, 0x02, 0x00, 0x18,
        0x41, 0x02, 0x00, 0x10, 0x02, 0x02, 0x00, 0x18, 0xad, 0xff, 0xff, 0x97, 0x1f, 0x20, 0x03, 0xd5,
        0xe1, 0x03, 0x1f, 0xaa, 0xa0, 0xfc, 0xff, 0x10, 0x01, 0x00, 0x40, 0xb9, 0xfe, 0x03, 0x01, 0xaa,
        0x01, 0x04, 0x40, 0xb9, 0xfd, 0x03, 0x01, 0xaa, 0x01, 0x08, 0x40, 0xb9, 0xfc, 0x03, 0x01, 0xaa,
        0x01, 0x0c, 0x40, 0xb9, 0x3f, 0x00, 0x00, 0x91, 0x00, 0x00, 0x80, 0xd2, 0xc0, 0x03, 0x5f, 0xd6
    };

    uint8_t* tmp = (uint8_t*)malloc(sizeof(payload) + 8 + len);
    memcpy(&tmp[0], &payload[0], sizeof(payload));
    put_unaligned_le32(tmp + sizeof(payload) + 0, addr);
    put_unaligned_le32(tmp + sizeof(payload) + 4, (uint32_t)len);
    memcpy(tmp + sizeof(payload) + 8, buf, len);
    bool ret = maskrom_upload_memory(0x471, tmp, sizeof(payload) + 8 + len, rc4);
    free(tmp);
    return ret;
}

bool RK_usb::maskrom_write_arm32_progress(uint32_t addr, void* buf, size_t len, bool rc4)
{
    progress_t progress(len);
    while(len > 0)
    {
        size_t n = len > 16384 ? 16384 : len;
        if(!maskrom_write_arm32(addr, buf, n, rc4))
        {
            progress.stop();
            return false;
        }
        addr += (uint32_t)n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::maskrom_write_arm64_progress(uint32_t addr, void* buf, size_t len, bool rc4)
{
    progress_t progress(len);
    while(len > 0)
    {
        size_t n = len > 16384 ? 16384 : len;
        if(!maskrom_write_arm64(addr, buf, n, rc4))
        {
            progress.stop();
            return false;
        }
        addr += (uint32_t)n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::maskrom_exec_arm32(uint32_t addr, bool rc4)
{
    static uint8_t payload[] = {
        0x00, 0x00, 0xa0, 0xe3, 0x17, 0x0f, 0x08, 0xee, 0x15, 0x0f, 0x07, 0xee, 0xd5, 0x0f, 0x07, 0xee,
        0x9a, 0x0f, 0x07, 0xee, 0x95, 0x0f, 0x07, 0xee, 0x06, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x4f, 0xe2, 0x00, 0xd0, 0x80, 0xe5,
        0x04, 0xe0, 0x80, 0xe5, 0x00, 0xe0, 0x0f, 0xe1, 0x08, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x11, 0xee,
        0x0c, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x1c, 0xee, 0x10, 0xe0, 0x80, 0xe5, 0x10, 0xef, 0x11, 0xee,
        0x14, 0xe0, 0x80, 0xe5, 0x00, 0x00, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3, 0x58, 0x20, 0x1f, 0xe5,
        0x02, 0xf0, 0xa0, 0xe1, 0x5c, 0x00, 0x4f, 0xe2, 0x00, 0xd0, 0x90, 0xe5, 0x04, 0xe0, 0x90, 0xe5,
        0x14, 0x10, 0x90, 0xe5, 0x10, 0x1f, 0x01, 0xee, 0x10, 0x10, 0x90, 0xe5, 0x10, 0x1f, 0x0c, 0xee,
        0x0c, 0x10, 0x90, 0xe5, 0x10, 0x1f, 0x01, 0xee, 0x08, 0x10, 0x90, 0xe5, 0x01, 0xf0, 0x29, 0xe1,
        0x1e, 0xff, 0x2f, 0xe1,
    };

    put_unaligned_le32(&payload[0x1c], addr);
    return maskrom_upload_memory(0x471, payload, sizeof(payload), rc4);
}

bool RK_usb::maskrom_exec_arm64(uint32_t addr, bool rc4)
{
    static uint8_t payload[] = {
        0xdf, 0x3f, 0x03, 0xd5, 0x9f, 0x3f, 0x03, 0xd5, 0x0a, 0x00, 0x00, 0x14, 0x44, 0x33, 0x22, 0x11,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0x10, 0xe1, 0x03, 0x1e, 0xaa, 0x01, 0x00, 0x00, 0xb9, 0xe1, 0x03, 0x1d, 0xaa,
        0x01, 0x04, 0x00, 0xb9, 0xe1, 0x03, 0x1c, 0xaa, 0x01, 0x08, 0x00, 0xb9, 0xe1, 0x03, 0x00, 0x91,
        0x01, 0x0c, 0x00, 0xb9, 0xe0, 0x03, 0x1f, 0xaa, 0xe1, 0x03, 0x1f, 0xaa, 0x82, 0xfd, 0xff, 0x18,
        0x40, 0x00, 0x1f, 0xd6, 0xe1, 0x03, 0x1f, 0xaa, 0x40, 0xfd, 0xff, 0x10, 0x01, 0x00, 0x40, 0xb9,
        0xfe, 0x03, 0x01, 0xaa, 0x01, 0x04, 0x40, 0xb9, 0xfd, 0x03, 0x01, 0xaa, 0x01, 0x08, 0x40, 0xb9,
        0xfc, 0x03, 0x01, 0xaa, 0x01, 0x0c, 0x40, 0xb9, 0x3f, 0x00, 0x00, 0x91, 0x00, 0x00, 0x80, 0xd2,
        0xc0, 0x03, 0x5f, 0xd6,
    };

    put_unaligned_le32(&payload[0x0c], addr);
    return maskrom_upload_memory(0x471, payload, sizeof(payload), rc4);
}

enum {
    USB_REQUEST_SIGN  = 0x55534243,    /* "USBC" */
    USB_RESPONSE_SIGN = 0x55534253,    /* "USBS" */
};

enum {
    USB_DIRECTION_OUT = 0x00,
    USB_DIRECTION_IN  = 0x80,
};

enum {
    OPCODE_TEST_UNIT_READY      = 0x00,
    OPCODE_READ_FLASH_ID        = 0x01,
    OPCODE_SET_DEVICE_ID        = 0x02,
    OPCODE_TEST_BAD_BLOCK       = 0x03,
    OPCODE_READ_SECTOR          = 0x04,
    OPCODE_WRITE_SECTOR         = 0x05,
    OPCODE_ERASE_NORMAL         = 0x06,
    OPCODE_WRITE_SPARE          = 0x07,
    OPCODE_READ_SPARE           = 0x08,
    OPCODE_ERASE_FORCE          = 0x0b,
    OPCODE_GET_VERSION          = 0x0c,
    OPCODE_READ_LBA             = 0x14,
    OPCODE_WRITE_LBA            = 0x15,
    OPCODE_ERASE_SYSDISK        = 0x16,
    OPCODE_READ_SDRAM           = 0x17,
    OPCODE_WRITE_SDRAM          = 0x18,
    OPCODE_EXEC_SDRAM           = 0x19,
    OPCODE_READ_FLASH_INFO      = 0x1a,
    OPCODE_READ_CHIP_INFO       = 0x1b,
    OPCODE_LOW_FORMAT           = 0x1c,
    OPCODE_SET_RESET_FLAG       = 0x1e,
    OPCODE_WRITE_EFUSE          = 0x1f,
    OPCODE_READ_EFUSE           = 0x20,
    OPCODE_READ_SPI_FLASH       = 0x21,
    OPCODE_WRITE_SPI_FLASH      = 0x22,
    OPCODE_WRITE_NEW_EFUSE      = 0x23,
    OPCODE_READ_NEW_EFUSE       = 0x24,
    OPCODE_ERASE_LBA            = 0x25,
    OPCODE_WRITE_VENDOR_STORAGE = 0x26,
    OPCODE_READ_VENDOR_STORAGE  = 0x27,
    OPCODE_READ_COM_LOG         = 0x28,
    OPCODE_SWITCH_STORAGE       = 0x2a,
    OPCODE_READ_STORAGE         = 0x2b,
    OPCODE_READ_OTP_CHIP        = 0x2c,
    OPCODE_SESSION              = 0x30,
    OPCODE_READ_CAPABILITY      = 0xaa,
    OPCODE_SWITCH_USB3          = 0xbb,
    OPCODE_RESET_DEVICE         = 0xff,
};

#pragma pack(push, 1)

struct usb_command_t
{
    uint8_t opcode;      /* Opcode */
    uint8_t subcode;     /* Subcode */
    uint8_t address[4];  /* Address */
    uint8_t reserved6;
    uint8_t size[2];     /* Size */
    uint8_t reserved9;
    uint8_t reserved10;
    uint8_t reserved11;
    uint8_t reserved12[4];
};

struct usb_request_t
{
    uint8_t signature[4]; /* Contains 'USBC' */
    uint8_t tag[4];       /* The random unique id */
    uint8_t length[4];    /* The data transfer length */
    uint8_t flag;         /* Direction in bit 7, IN(0x80), OUT(0x00) */
    uint8_t lun;          /* Lun (Flash chip select, normally 0) */
    uint8_t cmdlen;       /* Command Length 6/10/16 */
    usb_command_t cmd;
};

struct usb_response_t
{
    uint8_t signature[4]; /* Contains 'USBS' */
    uint8_t tag[4];       /* Same as original command */
    uint8_t residue[4];   /* Amount not transferred */
    uint8_t status;       /* Response status */
};

#pragma pack(pop)


bool RK_usb::usb_bulk_send(void* buf, size_t len)
{
    const size_t max_chunk = 128 * 1024;
    int bytes;
    while(len > 0)
    {
        int chunk = len < max_chunk ? (int)len : max_chunk;
        if(libusb_bulk_transfer(m_handle, m_epout, (uint8_t*)buf, chunk, &bytes, 2000) != 0)
        {
            printf("usb bulk send error\r\n");
            return false;
        }
        len -= bytes;
        buf = (uint8_t*)buf + bytes;
    }
    return true;
}

bool RK_usb::usb_bulk_recv(void* buf, size_t len)
{
    int bytes;
    while(len > 0)
    {
        if(libusb_bulk_transfer(m_handle, m_epin, (uint8_t*)buf, int(len), &bytes, 2000) != 0)
        {
            printf("usb bulk recv error\r\n");
            return false;
        }
        len -= bytes;
        buf = (uint8_t*)buf + bytes;
    }
    return true;
}

static inline uint32_t make_tag()
{
    uint32_t tag = 0;
    for(size_t i = 0; i < 4; i++)
        tag = (tag << 8) | (rand() & 0xff);
    return tag;
}

bool RK_usb::ready()
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_TEST_UNIT_READY;
    req.cmd.subcode = 0;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::version(uint8_t* buf)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 16);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_CHIP_INFO;

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
       return false;
    if(!usb_bulk_recv(buf, 16))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::capability(uint8_t* buf)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 8);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_CAPABILITY;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, 8))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::capability_support(enum capability_type_t type)
{
    uint8_t buf[8] = { 0 };

    if(capability(buf))
    {
        switch(type)
        {
        case CAPABILITY_TYPE_DIRECT_LBA:
            return (buf[0] & (1 << 0)) ? true : false;
        case CAPABILITY_TYPE_VENDOR_STORAGE:
            return (buf[0] & (1 << 1)) ? true : false;
        case CAPABILITY_TYPE_FIRST_4M_ACCESS:
            return (buf[0] & (1 << 2)) ? true : false;
        case CAPABILITY_TYPE_READ_LBA:
            return (buf[0] & (1 << 3)) ? true : false;
        case CAPABILITY_TYPE_NEW_VENDOR_STORAGE:
            return (buf[0] & (1 << 4)) ? true : false;
        case CAPABILITY_TYPE_READ_COM_LOG:
            return (buf[0] & (1 << 5)) ? true : false;
        case CAPABILITY_TYPE_READ_IDB_CONFIG:
            return (buf[0] & (1 << 6)) ? true : false;
        case CAPABILITY_TYPE_READ_SECURE_MODE:
            return (buf[0] & (1 << 7)) ? true : false;
        case CAPABILITY_TYPE_NEW_IDB:
            return (buf[1] & (1 << 0)) ? true : false;
        case CAPABILITY_TYPE_SWITCH_STORAGE:
            return (buf[1] & (1 << 1)) ? true : false;
        case CAPABILITY_TYPE_LBA_PARITY:
            return (buf[1] & (1 << 2)) ? true : false;
        case CAPABILITY_TYPE_READ_OTP_CHIP:
            return (buf[1] & (1 << 3)) ? true : false;
        case CAPABILITY_TYPE_SWITCH_USB3:
            return (buf[1] & (1 << 4)) ? true : false;
        default:
            break;
        }
    }
    return false;
}

bool RK_usb::reset(bool maskrom)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_RESET_DEVICE;
    req.cmd.subcode = maskrom ? 0x03 : 0x00;

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
    {
        libusb_reset_device(m_handle);
        return false;
    }
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::exec(uint32_t addr, uint32_t dtb)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_EXEC_SDRAM;
    req.cmd.subcode = 0xaa;
    put_unaligned_be32(&req.cmd.address[0], (uint32_t)addr);
    put_unaligned_be32(&req.cmd.size[0], (uint32_t)dtb);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::read_raw(uint32_t addr, void* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_READ_SDRAM;
    put_unaligned_be32(&req.cmd.address[0], addr);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)len);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::write_raw(uint32_t addr, void* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;
    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_WRITE_SDRAM;
    put_unaligned_be32(&req.cmd.address[0], addr);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)len);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_send(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::read(uint32_t addr, void* buf, size_t len)
{
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!read_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
    }
    return true;
}

bool RK_usb::write(uint32_t addr, void* buf, size_t len)
{
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!write_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
    }
    return true;
}

bool RK_usb::read_progress(uint32_t addr, void* buf, size_t len)
{
    progress_t progress(len);
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!read_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::write_progress(uint32_t addr, void* buf, size_t len)
{
    progress_t progress(len);
    while(len > 0)
    {
        uint32_t n = len > 16384 ? 16384 : uint32_t(len);
        if(!write_raw(addr, buf, n))
            return false;
        addr += n;
        buf = (uint8_t*)buf + n;
        len -= n;
        progress.update(n);
    }
    progress.stop();
    return true;
}

bool RK_usb::otp_read(uint8_t* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], uint32_t(len));
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_OTP_CHIP;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::sn_read(char* sn)
{
    if(sn)
    {
        char buf[512];
        if(flash_read_lba(0xfff00001, 1, buf))
        {
            uint32_t valid = get_unaligned_le32(&buf[0]);
            uint32_t len = get_unaligned_le32(&buf[4]);
            if((valid == 1) && (len >= 0) && (len <= 512 - 8))
            {
                memcpy(sn, &buf[8], len);
                sn[len] = '\0';
                return true;
            }
        }
    }
    return false;
}

bool RK_usb::sn_write(char* sn)
{
    if(sn)
    {
        size_t len = strlen(sn);
        if((len >= 0) && (len <= 512 - 8))
        {
            char buf[512];
            memset(buf, 0, sizeof(buf));
            put_unaligned_le32(&buf[0], 1);
            put_unaligned_le32(&buf[4], uint32_t(len));
            memcpy(&buf[8], sn, len);
            return flash_write_lba(0xfff00001, 1, buf);
        }
    }
    return false;
}

bool RK_usb::vs_read(uint16_t type, uint16_t index, uint8_t* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], uint32_t(len));
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_READ_VENDOR_STORAGE;
    req.cmd.subcode = 0;
    put_unaligned_be16(&req.cmd.address[0], index);
    put_unaligned_be16(&req.cmd.address[2], type);
    put_unaligned_be16(&req.cmd.size[0], uint32_t(len));

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::vs_write(uint16_t type, uint16_t index, uint8_t* buf, size_t len)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], uint32_t(len));
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_WRITE_VENDOR_STORAGE;
    req.cmd.subcode = 0;
    put_unaligned_be16(&req.cmd.address[0], index);
    put_unaligned_be16(&req.cmd.address[2], type);
    put_unaligned_be16(&req.cmd.size[0], uint32_t(len));

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_send(buf, len))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

enum storage_type_t RK_usb::storage_read()
{
    usb_request_t req;
    usb_response_t res;
    uint8_t buf[4];

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 4);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_STORAGE;

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return STORAGE_TYPE_UNKNOWN;
    if(!usb_bulk_recv(buf, 4))
        return STORAGE_TYPE_UNKNOWN;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return STORAGE_TYPE_UNKNOWN;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return STORAGE_TYPE_UNKNOWN;
    enum storage_type_t type = (enum storage_type_t)get_unaligned_le32(buf);
    switch(type)
    {
    case STORAGE_TYPE_FLASH:
    case STORAGE_TYPE_EMMC:
    case STORAGE_TYPE_SD:
    case STORAGE_TYPE_SD1:
    case STORAGE_TYPE_SPINOR:
    case STORAGE_TYPE_SPINAND:
    case STORAGE_TYPE_RAM:
    case STORAGE_TYPE_USB:
    case STORAGE_TYPE_SATA:
    case STORAGE_TYPE_PCIE:
        break;
    default:
        type = STORAGE_TYPE_UNKNOWN;
        break;
    }
    return type;
}

bool RK_usb::storage_switch(enum storage_type_t type)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_SWITCH_STORAGE;
    switch(type)
    {
        case STORAGE_TYPE_FLASH: req.cmd.subcode = 0; break;
        case STORAGE_TYPE_EMMC:  req.cmd.subcode = 1; break;
        case STORAGE_TYPE_SD:    req.cmd.subcode = 2; break;
        case STORAGE_TYPE_SD1:   req.cmd.subcode = 3; break;
        case STORAGE_TYPE_SPINOR:req.cmd.subcode = 9; break;
        case STORAGE_TYPE_SPINAND:req.cmd.subcode = 8;break;
        case STORAGE_TYPE_RAM:   req.cmd.subcode = 6; break;
        case STORAGE_TYPE_USB:   req.cmd.subcode = 7; break;
        case STORAGE_TYPE_SATA:  req.cmd.subcode = 10;break;
        case STORAGE_TYPE_PCIE:  req.cmd.subcode = 11;break;
        default: break;
    }
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::flash_detect(flash_info_t* info)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 11);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_FLASH_INFO;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(info, 11))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 5);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 6;
    req.cmd.opcode = OPCODE_READ_FLASH_ID;
    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&info->id[0], 5))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::flash_erase_lba_raw(uint32_t sec, uint32_t cnt)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], 0);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_ERASE_LBA;
    put_unaligned_be32(&req.cmd.address[0], sec);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)cnt);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}


bool RK_usb::flash_read_lba_raw(uint32_t sec, uint32_t cnt, void* buf)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], cnt << 9);
    req.flag = USB_DIRECTION_IN;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_READ_LBA;
    req.cmd.subcode = 0;
    put_unaligned_be32(&req.cmd.address[0], sec);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)cnt);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_recv(buf, cnt << 9))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::flash_write_lba_raw(uint32_t sec, uint32_t cnt, void* buf)
{
    usb_request_t req;
    usb_response_t res;

    memset(&req, 0, sizeof(usb_request_t));
    put_unaligned_be32(&req.signature[0], USB_REQUEST_SIGN);
    put_unaligned_be32(&req.tag[0], make_tag());
    put_unaligned_le32(&req.length[0], cnt << 9);
    req.flag = USB_DIRECTION_OUT;
    req.cmdlen = 10;
    req.cmd.opcode = OPCODE_WRITE_LBA;
    req.cmd.subcode = 0;
    put_unaligned_be32(&req.cmd.address[0], sec);
    put_unaligned_be16(&req.cmd.size[0], (uint16_t)cnt);

    if(!usb_bulk_send(&req, sizeof(usb_request_t)))
        return false;
    if(!usb_bulk_send(buf, cnt << 9))
        return false;
    if(!usb_bulk_recv(&res, sizeof(usb_response_t)))
        return false;
    if((get_unaligned_be32(&res.signature[0]) != USB_RESPONSE_SIGN) || (memcmp(&res.tag[0], &req.tag[0], 4) != 0))
        return false;
    return true;
}

bool RK_usb::flash_erase_lba(uint32_t sec, uint32_t cnt)
{
    while(cnt > 0)
    {
        uint32_t n = cnt > 16384 ? 16384 : cnt;
        if(!flash_erase_lba_raw(sec, n))
            return false;
        sec += n;
        cnt -= n;
    }
    return true;
}

bool RK_usb::flash_read_lba(uint32_t sec, uint32_t cnt, void* buf)
{
    while(cnt > 0)
    {
        uint32_t n = cnt > 16384 ? 16384 : cnt;
        if(!flash_read_lba_raw(sec, n, buf))
            return false;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
    }
    return true;
}

bool RK_usb::flash_write_lba(uint32_t sec, uint32_t cnt, void* buf)
{
    while(cnt > 0)
    {
        uint32_t n = cnt > 16384 ? 16384 : cnt;
        if(!flash_write_lba_raw(sec, n, buf))
            return false;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
    }
    return true;
}

bool RK_usb::flash_erase_lba_progress(uint32_t sec, uint32_t cnt)
{
    uint32_t MAXSEC = 16384;
    if(cnt <= 65536)
        MAXSEC = 128;

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        if(!flash_erase_lba_raw(sec, n))
            return false;
        sec += n;
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    return true;
}

bool RK_usb::flash_read_lba_progress(uint32_t sec, uint32_t cnt, void* buf)
{
    uint32_t MAXSEC = 16384;
    if(cnt <= 65536)
        MAXSEC = 128;

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        if(!flash_read_lba_raw(sec, n, buf))
            return false;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    return true;
}

bool RK_usb::flash_write_lba_progress(uint32_t sec, uint32_t cnt, void* buf)
{
    uint32_t MAXSEC = 16384;
    progress_t progress((uint64_t)cnt << 9);

    if(cnt <= 65536)
        MAXSEC = 128;
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        if(!flash_write_lba_raw(sec, n, buf))
            return 0;
        sec += n;
        buf = (uint8_t*)buf + (n << 9);
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    return true;
}

bool RK_usb::flash_read_lba_to_file_progress(uint32_t sec, uint32_t cnt, const char* filename)
{
    uint32_t MAXSEC = 16384;

    FILE* f = fopen(filename, "w");
    if(!f)
        return false;

    if(cnt <= 65536)
        MAXSEC = 128;

    void* buf = malloc(MAXSEC << 9);
    if(!buf)
    {
        fclose(f);
        return false;
    }

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        memset(buf, 0, MAXSEC << 9);
        if(!flash_read_lba_raw(sec, n, buf))
        {
            free(buf);
            fclose(f);
            return false;
        }
        if(fwrite(buf, 512, n, f) != n)
        {
            free(buf);
            fclose(f);
            return false;
        }
        sec += n;
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();

    free(buf);
    fclose(f);
    return true;
}

bool RK_usb::flash_write_lba_from_file_progress(uint32_t sec, uint32_t maxcnt, const char* filename)
{
    uint32_t MAXSEC = 16384;

    FILE* f = fopen(filename, "r");
    if(!f)
        return false;

    fseek(f, 0, SEEK_END);
    size_t len = ftell(f);
    if(len <= 0)
    {
        fclose(f);
        return false;
    }
    fseek(f, 0, SEEK_SET);

    uint32_t cnt = uint32_t(len >> 9);
    if(len % 512 != 0)
        cnt += 1;
    if(cnt <= 0)
        cnt = maxcnt - sec;
    else if(cnt > maxcnt - sec)
        cnt = maxcnt - sec;

    if(cnt <= 65536)
        MAXSEC = 128;

    void* buf = malloc(MAXSEC << 9);
    if(!buf)
    {
        fclose(f);
        return false;
    }

    progress_t progress((uint64_t)cnt << 9);
    while(cnt > 0)
    {
        uint32_t n = cnt > MAXSEC ? MAXSEC : cnt;
        memset(buf, 0, MAXSEC << 9);
        if(fread(buf, 512, n, f) != n)
        {
            free(buf);
            fclose(f);
            return false;
        }
        if(!flash_write_lba_raw(sec, n, buf))
        {
            free(buf);
            fclose(f);
            return false;
        }
        sec += n;
        cnt -= n;
        progress.update((uint64_t)n << 9);
    }
    progress.stop();
    free(buf);
    fclose(f);
    return true;
}
